<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Codequarium - Algorithmic Bio-Fluid Visualizer</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100;300;400;700&family=JetBrains+Mono:wght@100;400&display=swap');

        :root {
            --bg: #000000;
            --accent: #3366ff;
            --text-main: #ffffff;
            --text-dim: rgba(255, 255, 255, 0.5);
            --card-bg: rgba(255, 255, 255, 0.02);
            --frame-glow: rgba(51, 102, 255, 0);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            background-color: var(--bg);
            color: var(--text-main);
            font-family: 'Inter', sans-serif;
            line-height: 1.8;
            overflow-x: hidden;
            width: 100%;
            touch-action: manipulation;
            -webkit-text-size-adjust: 100%;
        }

        /* --- タイポグラフィ最適化 --- */
        h1, h2, h3 { 
            text-wrap: balance;
            word-break: keep-all; 
            overflow-wrap: anywhere;
            letter-spacing: 0.3em;
            text-transform: uppercase;
            font-weight: 100;
        }
        p { 
            text-wrap: pretty;
            max-width: 550px;
            color: var(--text-dim);
            font-weight: 300;
        }
        .keep-together { display: inline-block; white-space: nowrap; }

        /* --- エフェクトレイヤー --- */
        #vignette {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 35%, rgba(0,0,0,0.95) 150%);
            z-index: 5; pointer-events: none;
        }

        #background-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 1; pointer-events: none;
        }

        /* --- レイアウト構造 --- */
        section { padding: 80px 8%; position: relative; z-index: 20; }
        .container { max-width: 1100px; margin: 0 auto; }

        h1 { font-size: clamp(2.2rem, 8vw, 5.5rem); margin-bottom: 10px; line-height: 1.1; }
        .hero-sub { font-size: 0.7rem; color: var(--accent); letter-spacing: 0.4em; margin-bottom: 30px; }

        /* --- Hero --- */
        #hero {
            min-height: 100vh;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            padding: 20px 0; overflow: hidden;
        }

        #visualizer-mount {
            position: relative;
            z-index: 10;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.15);
            background: rgba(1, 1, 4, 0.98);
            border-radius: 4px;
            box-shadow: 0 0 60px var(--frame-glow);
            transform-style: preserve-3d;
            transition: width 0.8s cubic-bezier(0.16, 1, 0.3, 1), height 0.8s cubic-bezier(0.16, 1, 0.3, 1), transform 0.1s ease-out;
            margin: 0 auto;
        }

        /* デスクトップ用サイズ */
        #visualizer-mount.ratio-16-9 { width: 90vw; height: calc(90vw * 9 / 16); max-width: 1100px; max-height: 620px; }
        #visualizer-mount.ratio-4-5 { width: 85vw; height: calc(85vw * 5 / 4); max-width: 600px; max-height: 750px; }

        #fluid-engine {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            filter: blur(22px) contrast(110) brightness(1.2);
            pointer-events: none; z-index: 2;
        }

        canvas { display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; }

        .hero-controls {
            margin-top: 25px; display: flex; gap: 8px; flex-wrap: wrap; justify-content: center; z-index: 30;
            max-width: 95vw;
        }

        /* --- スマホ特化調整 --- */
        @media (max-width: 600px) {
            #hero { padding: 40px 0 20px; }
            /* スマホでは操作範囲を最大化（横幅いっぱい、縦も長めに） */
            #visualizer-mount.ratio-16-9 { width: 96vw; height: calc(96vw * 10 / 16); }
            #visualizer-mount.ratio-4-5 { width: 96vw; height: 135vw; } 
            
            section { padding: 60px 20px; }
            .hero-controls { gap: 6px; }
            .btn-zen { padding: 10px 12px; font-size: 7px; letter-spacing: 0.1em; }
        }

        /* --- UI Components --- */
        .guide-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); gap: 30px; margin-top: 50px; }
        .guide-item { padding: 25px; border-left: 1px solid rgba(255,255,255,0.1); transition: 0.3s; }
        .guide-item:hover { border-left-color: var(--accent); background: rgba(255,255,255,0.01); }
        .guide-num { font-family: 'JetBrains+Mono', monospace; color: var(--accent); font-size: 0.8rem; margin-bottom: 15px; display: block; opacity: 0.8; }
        .guide-item h3 { font-size: 0.75rem; margin-bottom: 12px; color: #fff; letter-spacing: 0.15em; line-height: 1.4; }
        .guide-item p { font-size: 0.8rem; }

        .btn-zen {
            font-family: 'JetBrains+Mono', monospace; font-size: 8px; letter-spacing: 0.2em; text-transform: uppercase;
            color: var(--text-dim); background: transparent; border: 1px solid rgba(255, 255, 255, 0.12);
            padding: 12px 18px; cursor: pointer; transition: 0.3s;
            outline: none; -webkit-tap-highlight-color: transparent;
        }
        .btn-zen:hover { color: #fff; border-color: var(--accent); background: rgba(51, 102, 255, 0.08); }
        .btn-zen.active { border-color: var(--accent); color: #fff; background: rgba(51, 102, 255, 0.05); }

        .mystic-link {
            display: inline-block; margin-top: 40px; padding: 18px 45px; background: #fff; color: #000;
            text-decoration: none; font-weight: 700; text-transform: uppercase; letter-spacing: 0.2em; font-size: 0.75rem;
            transition: 0.3s;
        }
        .mystic-link:hover { background: var(--accent); color: white; transform: scale(1.05); }

        .mount-hud {
            position: absolute; top: 15px; left: 20px; right: 20px;
            display: flex; justify-content: space-between;
            z-index: 20; pointer-events: none;
            font-family: 'JetBrains+Mono', monospace; font-size: 7px; opacity: 0.6;
        }
        
        #ui-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 5; pointer-events: none; }
    </style>
</head>
<body>

<div id="vignette"></div>
<canvas id="background-layer"></canvas>

<div id="hero">
    <div class="container" style="text-align: center;">
        <div class="hero-sub">The Coding Aquarium Project / <span class="keep-together">コードで描かれた水槽</span></div>
        <h1>Codequarium</h1>
        <p style="margin: 0 auto 30px; max-width: 550px;">
            <span class="keep-together">計算が呼吸し、</span><span class="keep-together">旋律が鼓動へと変わる。</span><br>
            <span class="keep-together">コードで描かれた</span><span class="keep-together">深淵の生態系。</span>
        </p>
    </div>

    <!-- メインマウント -->
    <div id="visualizer-mount" class="ratio-16-9">
        <div class="mount-hud">
            <div id="display-title">Bio-Void Standby</div>
            <div id="node-count-display">NODES: 1</div>
        </div>
        <canvas id="ui-canvas"></canvas>
        <div id="fluid-engine"><canvas id="art-canvas"></canvas></div>
    </div>

    <!-- コントロール -->
    <div class="hero-controls">
        <button class="btn-zen active" id="play-pause-btn" onclick="togglePlayback()">Play</button>
        <button class="btn-zen" onclick="loadSample('track1.mp3', 'コーヒーの湯気')">Coffee Steam</button>
        <button class="btn-zen" onclick="loadSample('track2.mp3', '雨上がりブレンド')">After Rain</button>
        <button class="btn-zen" onclick="loadSample('track3.mp3', '午後のカップと君')">Afternoon Cup</button>
        <label class="btn-zen">Import MP3 <input type="file" id="file-input" accept=".mp3,audio/mpeg,audio/mp3,audio/*" style="display:none;"></label>
        <button class="btn-zen" id="aspect-btn" style="border-color: rgba(100,150,255,0.4);">Change Layout</button>
    </div>
</div>

<section id="how-to">
    <div class="container">
        <h2>How to Interact / <span class="keep-together">操作方法</span></h2>
        <div class="guide-grid">
            <div class="guide-item">
                <span class="guide-num">01</span>
                <h3>Invoke Sound / <span class="keep-together">音楽を呼び覚ます</span></h3>
                <p>
                    <span class="keep-together">ライブラリから</span><span class="keep-together">曲を選ぶか、</span><span class="keep-together">手持ちのファイルを</span><span class="keep-together">読み込ませてください。</span><span class="keep-together">iPhoneの方は</span><span class="keep-together">「ファイル」アプリ内の</span><span class="keep-together">曲が選択可能です。</span>
                </p>
            </div>
            <div class="guide-item">
                <span class="guide-num">02</span>
                <h3>Manipulate Fluid / <span class="keep-together">流体をかき混ぜる</span></h3>
                <p>
                    <span class="keep-together">画面内のスライムを</span><span class="keep-together">ドラッグして</span><span class="keep-together">かき混ぜてください。</span><span class="keep-together">物理演算による</span><span class="keep-together">粘性と、</span><span class="keep-together">放した瞬間の</span><span class="keep-together">慣性を体験できます。</span>
                </p>
            </div>
            <div class="guide-item">
                <span class="guide-num">03</span>
                <h3>Observe Evolution / <span class="keep-together">進化を観察する</span></h3>
                <p>
                    <span class="keep-together">音楽のエネルギーが</span><span class="keep-together">高まると、</span><span class="keep-together">核は最大16個まで</span><span class="keep-together">自己分裂します。</span><span class="keep-together">それぞれの個体が</span><span class="keep-together">独立した意思を</span><span class="keep-together">持つかのように</span><span class="keep-together">泳ぎ回ります。</span>
                </p>
            </div>
            <div class="guide-item">
                <span class="guide-num">04</span>
                <h3>Feel the Recovery / <span class="keep-together">静寂への回帰</span></h3>
                <p>
                    <span class="keep-together">マウスを離すと、</span><span class="keep-together">空間の傾きや</span><span class="keep-together">粒子への干渉は</span><span class="keep-together">ゆっくりと収束し、</span><span class="keep-together">世界は元の</span><span class="keep-together">穏やかな状態へと</span><span class="keep-together">戻ります。</span>
                </p>
            </div>
        </div>
    </div>
</section>

<section id="footer-section" style="text-align: center;">
    <div class="container">
        <h2>Enter the Void / <span class="keep-together">深淵へ</span></h2>
        <p style="margin: 0 auto 10px;">
            <span class="keep-together">Codequariumは、</span><span class="keep-together">音楽と計算が</span><span class="keep-together">融合する</span><span class="keep-together">実験的な</span><span class="keep-together">デジタル水槽です。</span>
        </p>
        <p id="error-notice" style="font-size: 11px; opacity: 0.5; margin-bottom: 30px;">
            <span class="keep-together">※iPhoneで音楽が</span><span class="keep-together">選択できない場合は、</span><span class="keep-together">ミュージックアプリではなく</span><span class="keep-together">「ファイル」アプリ内の</span><span class="keep-together">曲を選んでください。</span>
        </p>
        <a href="https://www.threads.net/@hogushiya_kida?xmt=AQF0jg1JRo6B5FOakS_Gv36JaTHkwzBeYu6f729XkxglZCo" class="mystic-link" target="_blank">Connect on Threads / <span class="keep-together">Threadsで繋がる</span></a>
    </div>
</section>

<footer style="padding: 60px; text-align: center; font-size: 8px; opacity: 0.3; letter-spacing: 0.5em;">
    &copy; 2025 CODEQUARIUM PROJECT. CRAFTED BY CODE.
</footer>

<script>
    /**
     * CODEQUARIUM CORE ENGINE - Mobile Resilient & High-Res
     */
    const bgCanvas = document.getElementById('background-layer');
    const canvas = document.getElementById('art-canvas');
    const uiCanvas = document.getElementById('ui-canvas');
    const bgCtx = bgCanvas.getContext('2d');
    const ctx = canvas.getContext('2d');
    const uictx = uiCanvas.getContext('2d');
    const mount = document.getElementById('visualizer-mount');
    const vignette = document.getElementById('vignette');
    const nodeDisplay = document.getElementById('node-count-display');
    const displayTitle = document.getElementById('display-title');
    const fileInput = document.getElementById('file-input');
    const aspectBtn = document.getElementById('aspect-btn');
    const playPauseBtn = document.getElementById('play-pause-btn');

    let audioCtx, analyser, dataArray, prevDataArray, source, audioBuffer;
    let isInitialized = false, isPlaying = false;
    let startTime = 0, pauseOffset = 0;
    let currentMode = 'FLOW', globalVol = 0;
    
    let mouse = { x: 0, y: 0, globalX: 0, globalY: 0, active: false, down: false, influence: 0 };
    let dragNode = null; 
    let rotateX = 0, rotateY = 0;
    let dpr = window.devicePixelRatio || 1;

    const MAX_NODES = 16; 
    const PARTICLE_COUNT = 150; 
    let lastEvolutionTime = 0;
    const EVOLUTION_INTERVAL = 12;

    const FRICTION = 0.993; 
    const VISCOSITY = 0.012; 
    const BASE_SPEED_LIMIT = 0.45;

    class PhysicalPoint {
        constructor(x, y) {
            this.x = x; this.y = y; this.vx = 0; this.vy = 0;
            this.targetX = x; this.targetY = y;
        }
        solve(dynamicBoost = 0) {
            const logicalW = canvas.width / dpr;
            const logicalH = canvas.height / dpr;
            if (!isFinite(this.x) || !isFinite(this.y)) { 
                this.x = logicalW / 2; this.y = logicalH / 2; this.vx = 0; this.vy = 0; 
            }
            const dx = this.targetX - this.x;
            const dy = this.targetY - this.y;
            this.vx += dx * VISCOSITY; this.vy += dy * VISCOSITY;
            const limit = BASE_SPEED_LIMIT + dynamicBoost;
            const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy) || 0.01;
            if (speed > limit) { this.vx = (this.vx / speed) * limit; this.vy = (this.vy / speed) * limit; }
            this.x += this.vx; this.y += this.vy;
            this.vx *= FRICTION; this.vy *= FRICTION;
        }
    }

    class SwarmNode {
        constructor(id, x, y) {
            this.id = id; this.p = new PhysicalPoint(x, y); this.radius = 12;
            this.noiseSeedX = Math.random() * 2000; this.noiseSeedY = Math.random() * 2000;
            this.isDragging = false;
        }
        update(nodeVol, flux, nodes) {
            const logicalW = canvas.width / dpr;
            const logicalH = canvas.height / dpr;
            if (this.isDragging) {
                this.p.x = mouse.x; this.p.y = mouse.y;
                this.p.targetX = mouse.x; this.p.targetY = mouse.y;
            } else {
                const t = Date.now() * 0.00005;
                const cx = logicalW / 2; const cy = logicalH / 2;
                let tx = cx + Math.sin(t * (0.6 + this.id * 0.08) + this.noiseSeedX) * (logicalW * 0.32);
                let ty = cy + Math.cos(t * (0.5 + this.id * 0.12) + this.noiseSeedY) * (logicalH * 0.32);
                if (mouse.influence > 0.01) {
                    const dx = mouse.x - this.p.x, dy = mouse.y - this.p.y;
                    const d = Math.sqrt(dx * dx + dy * dy) || 1;
                    if (d < 300) { 
                        const force = (1 - d / 300) * 50 * mouse.influence;
                        tx += (dx / d) * force; ty += (dy / d) * force; 
                    }
                }
                nodes.forEach(other => {
                    if (other === this) return;
                    const dx = other.p.x - this.p.x, dy = other.p.y - this.p.y;
                    const dist = Math.sqrt(dx*dx + dy*dy) || 5;
                    const minDist = (this.radius + other.radius) * 1.25;
                    if (dist < minDist) {
                        const push = (minDist - dist) * 0.02;
                        this.p.vx -= (dx / dist) * push; this.p.vy -= (dy / dist) * push;
                    }
                });
                this.p.targetX = tx; this.p.targetY = ty;
                this.p.solve(flux * 0.45);
            }
            const pad = this.radius + 20; // 壁ギリギリまで動けるように調整
            if (this.p.x < pad) { this.p.vx = Math.abs(this.p.vx) * 0.6; this.p.x = pad; }
            if (this.p.x > logicalW - pad) { this.p.vx = -Math.abs(this.p.vx) * 0.6; this.p.x = logicalW - pad; }
            if (this.p.y < pad) { this.p.vy = Math.abs(this.p.vy) * 0.6; this.p.y = pad; }
            if (this.p.y > logicalH - pad) { this.p.vy = -Math.abs(this.p.vy) * 0.6; this.p.y = logicalH - pad; }
            const targetR = 26 + nodeVol * 80 + flux * 135;
            this.radius += (targetR - this.radius) * (targetR > this.radius ? 0.3 : 0.08);
        }
        draw(hue) {
            if (!isFinite(this.p.x) || !isFinite(this.p.y) || this.radius <= 1) return;
            const px = this.p.x * dpr, py = this.p.y * dpr, pr = this.radius * dpr;
            const g = ctx.createRadialGradient(px, py, 0, px, py, pr);
            const intensity = (this.isDragging || currentMode === 'BANG') ? 1.0 : 0.68;
            g.addColorStop(0, `hsla(${hue}, 80%, 92%, ${intensity})`); 
            g.addColorStop(0.2, `hsla(${hue}, 70%, 50%, 0.65)`);
            g.addColorStop(0.75, `hsla(${hue}, 90%, 5%, 0.18)`);
            g.addColorStop(1, 'transparent');
            ctx.fillStyle = g; ctx.beginPath(); ctx.arc(px, py, pr, 0, Math.PI * 2); ctx.fill();
        }
    }

    class BioParticle {
        constructor() { this.init(true); }
        init(randomPos = false) {
            if (randomPos) { this.x = Math.random() * bgCanvas.width; this.y = Math.random() * bgCanvas.height; } 
            else { const a = Math.random()*Math.PI*2, d = Math.random()*150*dpr; this.x = (bgCanvas.width/2) + Math.cos(a)*d; this.y = (bgCanvas.height/2) + Math.sin(a)*d; }
            this.z = Math.random() * 2 + 0.5; this.baseAngle = Math.random() * Math.PI * 2;
            this.speed = (Math.random() * 0.12 + 0.05) / this.z * dpr; this.size = (Math.random() * 1.5 + 0.4) * dpr;
            this.alpha = Math.random() * 0.2 + 0.1; this.flickerS = Math.random() * 0.03 + 0.01; this.vx = 0; this.vy = 0;
        }
        update(bass) {
            const cx = bgCanvas.width / 2, cy = bgCanvas.height / 2, t = Date.now() * 0.001;
            const flowA = t * (0.04 / this.z) + this.baseAngle;
            const flowX = Math.cos(flowA) * this.speed, flowY = Math.sin(flowA) * this.speed;
            const dx = this.x - cx, dy = this.y - cy, dist = Math.sqrt(dx*dx + dy*dy) || 1;
            this.vx += (dx / dist) * bass * 0.38 * dpr;
            if (currentMode === 'BANG') { this.vx += (dx / dist) * 1.8 * dpr; this.vy += (dy / dist) * 1.8 * dpr; }
            if (mouse.influence > 0.01) {
                const mdx = this.x - mouse.globalX * dpr, mdy = this.y - mouse.globalY * dpr;
                const mdist = Math.sqrt(mdx*mdx + mdy*mdy) || 1;
                if (mdist < 300 * dpr) { 
                    const f = (1 - mdist / (300 * dpr)) * 2.8 * mouse.influence * dpr; 
                    this.vx += (mdx/mdist)*f; this.vy += (mdy/mdist)*f; 
                }
            }
            this.x += flowX + this.vx; this.y += flowY + this.vy; this.vx *= 0.93; this.vy *= 0.93;
            if (this.x < -200 || this.x > bgCanvas.width + 200 || this.y < -200 || this.y > bgCanvas.height + 200) this.init(false);
        }
        draw(hue, bass) {
            const blink = Math.sin(Date.now() * this.flickerS) * 0.15;
            const a = this.alpha + globalVol * 0.2 + bass * 0.45 + blink;
            bgCtx.fillStyle = `hsla(${hue}, 75%, 85%, ${Math.min(1, a)})`;
            bgCtx.beginPath(); bgCtx.arc(this.x, this.y, this.size * (1 + bass * 1.6), 0, Math.PI * 2); bgCtx.fill();
        }
    }

    let nodes = []; let particles = [];

    function setup() {
        syncSizes();
        dataArray = new Uint8Array(256); prevDataArray = new Uint8Array(256);
        nodes = [new SwarmNode(0, (canvas.width/dpr)/2, (canvas.height/dpr)/2)];
        particles = Array.from({ length: PARTICLE_COUNT }, () => new BioParticle());
        animate();
    }

    function addEvolutionNode() {
        if (nodes.length >= MAX_NODES) return;
        const parent = nodes[Math.floor(Math.random() * nodes.length)];
        const newNode = new SwarmNode(nodes.length, parent.p.x + 5, parent.p.y + 5);
        newNode.p.vx = (Math.random() - 0.5) * 6; newNode.p.vy = (Math.random() - 0.5) * 6;
        nodes.push(newNode);
    }

    function syncSizes() {
        dpr = window.devicePixelRatio || 1;
        const oldW = canvas.width / dpr, oldH = canvas.height / dpr;
        bgCanvas.width = window.innerWidth * dpr; bgCanvas.height = window.innerHeight * dpr;
        const rect = mount.getBoundingClientRect();
        if (rect && rect.width > 0) {
            canvas.width = uiCanvas.width = rect.width * dpr;
            canvas.height = uiCanvas.height = rect.height * dpr;
            if (oldW > 0) {
                const cx = (canvas.width/dpr) / 2, cy = (canvas.height/dpr) / 2;
                nodes.forEach(n => {
                    n.p.x = cx + (n.p.x - oldW/2) * ((canvas.width/dpr) / oldW);
                    n.p.y = cy + (n.p.y - oldH/2) * ((canvas.height/dpr) / oldH);
                    n.p.targetX = cx + (n.p.targetX - oldW/2) * ((canvas.width/dpr) / oldW);
                    n.p.targetY = cy + (n.p.targetY - oldH/2) * ((canvas.height/dpr) / oldH);
                });
            }
        }
    }

    function updateMousePos(e) {
        const rect = mount.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        mouse.x = clientX - rect.left; mouse.y = clientY - rect.top;
        mouse.globalX = clientX; mouse.globalY = clientY;
        rotateY = ((clientX / window.innerWidth) - 0.5) * 8; rotateX = ((clientY / window.innerHeight) - 0.5) * -8;
    }

    mount.addEventListener('mousedown', (e) => { mouse.down = true; updateMousePos(e); let target = null; nodes.forEach(n => { if (Math.hypot(n.p.x - mouse.x, n.p.y - mouse.y) < 120) target = n; }); if (target) { dragNode = target; dragNode.isDragging = true; } });
    window.addEventListener('mousemove', (e) => { updateMousePos(e); mouse.active = true; });
    window.addEventListener('mouseup', () => { mouse.down = false; if (dragNode) { dragNode.isDragging = false; dragNode = null; } });
    mount.addEventListener('mouseleave', () => { mouse.active = false; });
    mount.addEventListener('touchstart', (e) => { if (e.target.tagName !== 'BUTTON') e.preventDefault(); mouse.down = true; mouse.active = true; updateMousePos(e); let target = null; nodes.forEach(n => { if (Math.hypot(n.p.x - mouse.x, n.p.y - mouse.y) < 100) target = n; }); if (target) { dragNode = target; dragNode.isDragging = true; } }, {passive: false});
    window.addEventListener('touchmove', (e) => { if(mouse.down) e.preventDefault(); updateMousePos(e); }, {passive: false});
    window.addEventListener('touchend', () => { mouse.down = false; mouse.active = false; if (dragNode) { dragNode.isDragging = false; dragNode = null; } });

    function startPlayback(offset) {
        if (!audioBuffer) return;
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if (audioCtx.state === 'suspended') audioCtx.resume();
        if (!analyser) { analyser = audioCtx.createAnalyser(); analyser.fftSize = 512; analyser.connect(audioCtx.destination); }
        if (source) { try { source.stop(); } catch(e) {} source.disconnect(); }
        source = audioCtx.createBufferSource();
        source.buffer = audioBuffer; source.connect(analyser); source.start(0, offset);
        startTime = audioCtx.currentTime - offset; isPlaying = true;
        playPauseBtn.innerText = "Pause"; playPauseBtn.classList.add('active');
    }

    function togglePlayback() { if (!audioBuffer) return; if (isPlaying) { pauseOffset = audioCtx.currentTime - startTime; if (source) source.stop(); isPlaying = false; playPauseBtn.innerText = "Play"; playPauseBtn.classList.remove('active'); } else { startPlayback(pauseOffset % audioBuffer.duration); } }

    function loadSample(fileName, label) {
        if (displayTitle) displayTitle.innerText = "Loading...";
        fetch(fileName).then(res => { if(!res.ok) throw new Error(); return res.arrayBuffer(); }).then(buffer => {
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            audioCtx.decodeAudioData(buffer, (decoded) => {
                audioBuffer = decoded; if (displayTitle) displayTitle.innerText = label; 
                pauseOffset = 0; startPlayback(0); isInitialized = true;
                nodes = [new SwarmNode(0, (canvas.width/dpr)/2, (canvas.height/dpr)/2)]; lastEvolutionTime = 0;
            });
        }).catch(err => {
            const notice = document.getElementById('error-notice');
            if (notice) notice.innerHTML = "<span class='keep-together' style='color:#ff3366'>エラー：公開サーバー経由で実行してください。</span>";
        });
    }
    window.loadSample = loadSample;

    fileInput.onchange = (e) => {
        if (!e.target.files[0]) return;
        if (displayTitle) displayTitle.innerText = "Reading...";
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if (audioCtx.state === 'suspended') audioCtx.resume();
        const reader = new FileReader();
        reader.onload = (ev) => {
            audioCtx.decodeAudioData(ev.target.result, (buf) => {
                audioBuffer = buf; if (displayTitle) displayTitle.innerText = e.target.files[0].name;
                pauseOffset = 0; startPlayback(0); isInitialized = true;
                nodes = [new SwarmNode(0, (canvas.width/dpr)/2, (canvas.height/dpr)/2)]; lastEvolutionTime = 0;
            });
        };
        reader.readAsArrayBuffer(e.target.files[0]);
    };

    aspectBtn.onclick = () => {
        const is169 = mount.classList.contains('ratio-16-9');
        mount.classList.remove('ratio-16-9', 'ratio-4-5'); mount.classList.add(is169 ? 'ratio-4-5' : 'ratio-16-9');
        let animStart = null;
        function step(ts) { if(!animStart) animStart = ts; syncSizes(); if (ts - animStart < 1100) requestAnimationFrame(step); }
        requestAnimationFrame(step);
    };

    function triggerBang() {
        currentMode = 'BANG';
        if (nodes.length < MAX_NODES) addEvolutionNode();
        nodes.forEach(n => { n.p.vx += (Math.random()-0.5)*0.35; n.p.vy += (Math.random()-0.5)*0.35; });
        setTimeout(() => { if (currentMode === 'BANG') currentMode = 'FLOW'; }, 10000);
    }

    function animate() {
        requestAnimationFrame(animate);
        if (mouse.active) { mouse.influence += (1 - mouse.influence) * 0.1; } 
        else { mouse.influence += (0 - mouse.influence) * 0.05; rotateX *= 0.95; rotateY *= 0.95; }
        if (isInitialized && isPlaying && analyser) { 
            analyser.getByteFrequencyData(dataArray); 
            const current = audioCtx.currentTime - startTime;
            if (current > lastEvolutionTime + EVOLUTION_INTERVAL && nodes.length < MAX_NODES) { addEvolutionNode(); lastEvolutionTime = current; }
            if (current >= audioBuffer.duration) { isPlaying = false; playPauseBtn.innerText = "Play"; pauseOffset = 0; }
        } else { if (dataArray) dataArray.fill(0); }
        let s = 0, f = 0, b = 0, pIndex = 0;
        if (dataArray) {
            for (let i = 0; i < dataArray.length; i++) { s += dataArray[i]; if (i < 15) b += dataArray[i]; f += Math.max(0, dataArray[i] - (prevDataArray ? prevDataArray[i] : 0)); if (dataArray[i] > (dataArray[pIndex] || 0)) { pIndex = i; } }
            const avg = s / dataArray.length / 255; const bassAvg = b / 15 / 255; const fAvg = f / dataArray.length / 255;
            globalVol = avg; if (!prevDataArray) prevDataArray = new Uint8Array(256); prevDataArray.set(dataArray);
            const hue = (pIndex / 128) * 360 + (Date.now() * 0.003 % 360);
            if (isInitialized) {
                mount.style.setProperty('--frame-glow', `hsla(${hue}, 70%, 70%, ${avg * 0.8})`);
                mount.style.borderColor = `hsla(${hue}, 60%, 80%, ${0.1 + avg * 0.5})`;
                mount.style.boxShadow = `0 0 45px hsla(${hue}, 80%, 50%, ${avg * 0.6}), inset 0 0 100px hsla(${hue}, 80%, 15%, ${bassAvg * 0.4})`;
                vignette.style.transform = `scale(${1 + fAvg * 0.15})`; vignette.style.opacity = 0.4 + avg * 0.6;
            }
            if (currentMode !== 'BANG' && isInitialized && isPlaying && fAvg > 0.24) triggerBang();
            ctx.fillStyle = 'rgba(1, 1, 6, 0.2)'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            bgCtx.clearRect(0, 0, bgCanvas.width, bgCanvas.height);
            particles.forEach(p => { p.update(bassAvg); p.draw(hue, bassAvg); });
            uictx.clearRect(0, 0, uiCanvas.width, uiCanvas.height);
            mount.style.transform = `rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;
            nodeDisplay.innerText = `NODES: ${nodes.length}`;
            nodes.forEach((n, i) => { n.update(isInitialized ? dataArray[i % 32]/255 : 0, fAvg, nodes); n.draw(hue); });
            uictx.save();
            const barCount = 24, barGap = 12 * dpr, barW = 2.5 * dpr;
            const startX = uiCanvas.width / 2 - (barCount * barGap) / 2;
            const baselineY = uiCanvas.height - 110 * dpr; 
            for (let i = 0; i < barCount; i++) {
                const val = dataArray[i] || 0; const h = (val / 255) * 65 * dpr; if (h <= 0) continue;
                uictx.fillStyle = `hsla(${hue}, 80%, 90%, 0.3)`; uictx.shadowBlur = 15 * dpr; uictx.shadowColor = `hsla(${hue}, 80%, 50%, 0.6)`;
                uictx.fillRect(startX + i * barGap, baselineY - h, barW, h);
            }
            uictx.restore();
        }
    }
    window.addEventListener('resize', syncSizes);
    setup();
</script>
</body>
</html>
