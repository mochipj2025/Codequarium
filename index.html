<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Codequarium - Algorithmic Bio-Fluid Visualizer</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100;300;400;700&family=JetBrains+Mono:wght@100;400&display=swap');

        :root {
            --bg: #000000;
            --accent: #3366ff;
            --text-main: #ffffff;
            --text-dim: rgba(255, 255, 255, 0.5);
            --card-bg: rgba(255, 255, 255, 0.02);
            --frame-glow: rgba(100, 150, 255, 0);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            background-color: var(--bg);
            color: var(--text-main);
            font-family: 'Inter', sans-serif;
            line-height: 1.6;
            overflow-x: hidden;
            width: 100%;
        }

        /* --- エフェクト --- */
        #vignette {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 30%, rgba(0,0,0,0.95) 150%);
            z-index: 5; pointer-events: none;
        }

        #background-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 1; pointer-events: none;
        }

        /* --- セクション構造 --- */
        section { padding: 80px 5%; position: relative; z-index: 20; }
        .container { max-width: 1200px; margin: 0 auto; }

        h1, h2, h3 { font-weight: 100; letter-spacing: 0.3em; text-transform: uppercase; }
        h1 { font-size: clamp(2.2rem, 8vw, 5.5rem); margin-bottom: 10px; line-height: 1.1; }
        .hero-sub { font-size: 0.75rem; color: var(--accent); letter-spacing: 0.5em; margin-bottom: 30px; }

        p { font-weight: 300; color: var(--text-dim); margin-bottom: 20px; max-width: 700px; }

        /* --- メインビジュアライザー (Hero) --- */
        #hero {
            min-height: 100vh;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            padding: 40px 0; overflow: hidden;
        }

        #visualizer-mount {
            position: relative;
            z-index: 10;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.12);
            background: rgba(1, 1, 4, 0.98);
            border-radius: 4px;
            box-shadow: 0 0 60px var(--frame-glow);
            transform-style: preserve-3d;
            /* サイズ変更を確実に動作させる transition */
            transition: width 1.2s cubic-bezier(0.16, 1, 0.3, 1), height 1.2s cubic-bezier(0.16, 1, 0.3, 1), transform 0.1s ease-out;
            margin: 0 auto;
        }

        /* アスペクト比クラス：詳細度を上げ、確実に上書き */
        #visualizer-mount.ratio-16-9 { width: 90vw; height: calc(90vw * 9 / 16); max-width: 1100px; max-height: 620px; }
        #visualizer-mount.ratio-4-5 { width: 85vw; height: calc(85vw * 5 / 4); max-width: 600px; max-height: 750px; }

        #fluid-engine {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            filter: blur(24px) contrast(95) brightness(1.2);
            pointer-events: none; z-index: 2;
        }

        canvas { display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; }

        .hero-controls {
            margin-top: 30px; display: flex; gap: 8px; flex-wrap: wrap; justify-content: center; z-index: 30;
            max-width: 95vw;
        }

        /* --- ボタン・UI --- */
        .btn-zen {
            font-family: 'JetBrains+Mono', monospace; font-size: 8px; letter-spacing: 0.2em; text-transform: uppercase;
            color: var(--text-dim); background: transparent; border: 1px solid rgba(255, 255, 255, 0.12);
            padding: 10px 18px; cursor: pointer; transition: 0.3s;
            outline: none;
        }
        .btn-zen:hover { color: #fff; border-color: var(--accent); background: rgba(51, 102, 255, 0.08); }
        .btn-zen:active { transform: scale(0.95); }

        .mystic-link {
            display: inline-block; margin-top: 40px; padding: 18px 40px; background: #fff; color: #000;
            text-decoration: none; font-weight: 700; text-transform: uppercase; letter-spacing: 0.2em; font-size: 0.7rem;
            transition: 0.3s;
        }
        .mystic-link:hover { background: var(--accent); color: white; }

        #node-count-display {
            position: absolute; top: 15px; right: 20px; font-family: 'JetBrains+Mono', monospace; font-size: 7px; opacity: 0.4; pointer-events: none;
        }

        #ui-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 5; pointer-events: none; }

        @media (max-width: 600px) {
            #visualizer-mount.ratio-16-9 { width: 95vw; height: calc(95vw * 9 / 16); }
            #visualizer-mount.ratio-4-5 { width: 92vw; height: 115vw; }
            section { padding: 80px 20px; }
            .btn-zen { padding: 8px 12px; font-size: 7px; }
        }
    </style>
</head>
<body>

<div id="vignette"></div>
<canvas id="background-layer"></canvas>

<div id="hero">
    <div class="container" style="text-align: center;">
        <div class="hero-sub">The Coding Aquarium Project</div>
        <h1>Codequarium</h1>
        <p style="margin: 0 auto 35px;">計算が呼吸し、旋律が鼓動へと変わる。<br>コードで描かれた深淵の生態系。</p>
    </div>

    <!-- メインマウント -->
    <div id="visualizer-mount" class="ratio-16-9">
        <div id="node-count-display">NODES: 1</div>
        <canvas id="ui-canvas"></canvas>
        <div id="fluid-engine"><canvas id="art-canvas"></canvas></div>
    </div>

    <!-- コントロール：トラック名を track1.mp3 等に同期 -->
    <div class="hero-controls">
        <button class="btn-zen" onclick="loadSample('track1.mp3', 'コーヒーの湯気')">Coffee Steam</button>
        <button class="btn-zen" onclick="loadSample('track2.mp3', '雨上がりブレンド')">After Rain</button>
        <button class="btn-zen" onclick="loadSample('track3.mp3', '午後のカップと君')">Afternoon Cup</button>
        <label class="btn-zen">Import MP3 <input type="file" id="file-input" accept="audio/*" style="display:none;"></label>
        <button class="btn-zen" id="aspect-btn" style="border-color: rgba(100,150,255,0.4); color: #fff;">Change Layout</button>
    </div>
</div>

<section id="features">
    <div class="container">
        <h2>System Ecosystem</h2>
        <div class="feature-grid">
            <div class="feature-card">
                <h3>Bio-Fluid Evolution</h3>
                <p>音楽のエネルギーを糧とし、最大16個の独立した核へと自己分裂するアルゴリズム。各個体は自律的な意志を持ち、空間を優雅に漂います。</p>
            </div>
            <div class="feature-card">
                <h3>Tactile Interaction</h3>
                <p>水槽に指を浸すように、生命体を直接ドラッグして操作可能。流体特有の粘り気のある結合と、放した瞬間の慣性が現実に近い感触を生みます。</p>
            </div>
            <div class="feature-card">
                <h3>Spectral Synthesis</h3>
                <p>周波数解析に基づき、空間の色温度をリアルタイムに制御。音の高さと強さに応じて、深海の静寂から眩い閃光まで変容し続けます。</p>
            </div>
            <div class="feature-card">
                <h3>Vortex Circulation</h3>
                <p>背景に漂う微細な光の粒は、海洋循環を模した流体場に従って動きます。キック音に合わせて空間全体が拍動し、没入感を極限まで高めます。</p>
            </div>
        </div>
    </div>
</section>

<section id="footer-section" style="text-align: center;">
    <div class="container">
        <h2>Enter the Void</h2>
        <p style="margin: 0 auto 10px;">Codequariumは、音楽と計算が融合する実験的なアートプロジェクトです。</p>
        <p style="font-size: 11px; opacity: 0.5;">※サンプル曲の再生にはローカルサーバー（Live Server等）が必要です。直接ファイルを開く場合は「Import MP3」をご利用ください。</p>
        <a href="https://github.com/your-username/codequarium" class="mystic-link">Explore Repository</a>
    </div>
</section>

<footer style="padding: 60px; text-align: center; font-size: 8px; opacity: 0.3; letter-spacing: 0.5em;">
    &copy; 2025 CODEQUARIUM PROJECT. CRAFTED BY CODE.
</footer>

<script>
    /**
     * CODEQUARIUM CORE ENGINE
     */
    const bgCanvas = document.getElementById('background-layer');
    const canvas = document.getElementById('art-canvas');
    const uiCanvas = document.getElementById('ui-canvas');
    const bgCtx = bgCanvas.getContext('2d');
    const ctx = canvas.getContext('2d');
    const uictx = uiCanvas.getContext('2d');
    const mount = document.getElementById('visualizer-mount');
    const vignette = document.getElementById('vignette');
    const nodeDisplay = document.getElementById('node-count-display');
    const fileInput = document.getElementById('file-input');
    const aspectBtn = document.getElementById('aspect-btn');

    let audioCtx, analyser, dataArray, prevDataArray, source, audioBuffer;
    let isInitialized = false, isPlaying = false;
    let startTime = 0, pauseOffset = 0;
    let currentMode = 'FLOW', globalVol = 0;
    let mouse = { x: 0, y: 0, active: false, down: false };
    let dragNode = null; 
    let rotateX = 0, rotateY = 0;

    const MAX_NODES = 16; 
    const PARTICLE_COUNT = 150; 
    let lastEvolutionTime = 0;
    const EVOLUTION_INTERVAL = 12;

    const FRICTION = 0.993; 
    const VISCOSITY = 0.012; 
    const BASE_SPEED_LIMIT = 0.45;

    class PhysicalPoint {
        constructor(x, y) {
            this.x = x; this.y = y; this.vx = 0; this.vy = 0;
            this.targetX = x; this.targetY = y;
        }
        teleport(x, y) {
            if (!isFinite(x) || !isFinite(y)) return;
            this.x = x; this.y = y;
            this.targetX = x; this.targetY = y;
            this.vx = 0; this.vy = 0;
        }
        sync(x, y) { if (isFinite(x) && isFinite(y)) { this.targetX = x; this.targetY = y; } }
        solve(dynamicBoost = 0) {
            const dx = this.targetX - this.x;
            const dy = this.targetY - this.y;
            this.vx += dx * VISCOSITY; this.vy += dy * VISCOSITY;
            const limit = BASE_SPEED_LIMIT + dynamicBoost;
            const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy) || 0.01;
            if (speed > limit) { this.vx = (this.vx / speed) * limit; this.vy = (this.vy / speed) * limit; }
            this.x += this.vx; this.y += this.vy;
            this.vx *= FRICTION; this.vy *= FRICTION;
        }
    }

    class SwarmNode {
        constructor(id, x, y) {
            this.id = id;
            this.p = new PhysicalPoint(x, y);
            this.radius = 12;
            this.noiseSeedX = Math.random() * 2000;
            this.noiseSeedY = Math.random() * 2000;
            this.isDragging = false;
        }
        update(nodeVol, flux, nodes) {
            if (this.isDragging) {
                const ox = this.p.x, oy = this.p.y;
                this.p.x = mouse.x; this.p.y = mouse.y;
                this.p.vx = (this.p.x - ox) * 0.4; this.p.vy = (this.p.y - oy) * 0.4;
                this.p.targetX = this.p.x; this.p.targetY = this.p.y;
            } else {
                const t = Date.now() * 0.00005;
                const cx = canvas.width / 2; const cy = canvas.height / 2;
                let tx = cx + Math.sin(t * (0.6 + this.id * 0.08) + this.noiseSeedX) * (canvas.width * 0.32);
                let ty = cy + Math.cos(t * (0.5 + this.id * 0.12) + this.noiseSeedY) * (canvas.height * 0.32);
                
                if (mouse.active && !mouse.down) {
                    const dx = mouse.x - this.p.x, dy = mouse.y - this.p.y;
                    const d = Math.sqrt(dx * dx + dy * dy) || 0.01;
                    if (d < 300) { tx += (dx / d) * 45; ty += (dy / d) * 45; }
                }
                if (flux > 0.22) {
                    const a = Math.random() * Math.PI * 2;
                    this.p.vx += Math.cos(a) * flux * 3.8; this.p.vy += Math.sin(a) * flux * 3.8;
                }
                nodes.forEach(other => {
                    if (other === this) return;
                    const dx = other.p.x - this.p.x, dy = other.p.y - this.p.y;
                    const dist = Math.sqrt(dx * dx + dy * dy) || 0.01;
                    const minDist = (this.radius + other.radius) * 1.25;
                    if (dist < minDist) {
                        const push = (minDist - dist) * 0.025;
                        this.p.vx -= (dx / dist) * push; this.p.vy -= (dy / dist) * push;
                    } else if (dist < 220) {
                        this.p.vx += (dx / dist) * 0.0001; this.p.vy += (dy / dist) * 0.0001;
                    }
                });
                this.p.sync(tx, ty); this.p.solve(flux * 0.45);
            }
            const pad = this.radius + 35;
            if (this.p.x < pad) { this.p.vx = Math.abs(this.p.vx) * 0.6; this.p.x = pad; }
            if (this.p.x > canvas.width - pad) { this.p.vx = -Math.abs(this.p.vx) * 0.6; this.p.x = canvas.width - pad; }
            if (this.p.y < pad) { this.p.vy = Math.abs(this.p.vy) * 0.6; this.p.y = pad; }
            if (this.p.y > canvas.height - pad) { this.p.vy = -Math.abs(this.p.vy) * 0.6; this.p.y = canvas.height - pad; }
            
            const targetR = 26 + nodeVol * 80 + flux * 135;
            const lerpS = targetR > this.radius ? 0.3 : 0.08;
            this.radius += (targetR - this.radius) * lerpS;
        }
        draw(hue) {
            if (!isFinite(this.p.x) || !isFinite(this.p.y) || this.radius <= 1) return;
            const g = ctx.createRadialGradient(this.p.x, this.p.y, 0, this.p.x, this.p.y, this.radius);
            const intensity = (this.isDragging || currentMode === 'BANG') ? 1.0 : 0.68;
            g.addColorStop(0, `hsla(${hue}, 80%, 92%, ${intensity})`); 
            g.addColorStop(0.2, `hsla(${hue}, 70%, 50%, 0.65)`);
            g.addColorStop(0.75, `hsla(${hue}, 90%, 5%, 0.18)`);
            g.addColorStop(1, 'transparent');
            ctx.fillStyle = g; ctx.beginPath(); ctx.arc(this.p.x, this.p.y, this.radius, 0, Math.PI * 2); ctx.fill();
        }
    }

    class BioParticle {
        constructor() { this.init(true); }
        init(randomPos = false) {
            if (randomPos) { 
                this.x = Math.random() * bgCanvas.width; this.y = Math.random() * bgCanvas.height; 
            } else { 
                const a = Math.random()*Math.PI*2, d = Math.random()*150; 
                this.x = (bgCanvas.width/2) + Math.cos(a)*d; this.y = (bgCanvas.height/2) + Math.sin(a)*d; 
            }
            this.z = Math.random() * 2 + 0.5; this.baseAngle = Math.random() * Math.PI * 2;
            this.speed = (Math.random() * 0.12 + 0.05) / this.z; this.size = Math.random() * 1.5 + 0.4;
            this.alpha = Math.random() * 0.2 + 0.1; this.flickerS = Math.random() * 0.03 + 0.01; this.vx = 0; this.vy = 0;
        }
        update(bass) {
            const centerX = bgCanvas.width / 2, centerY = bgCanvas.height / 2, t = Date.now() * 0.001;
            const flowA = t * (0.04 / this.z) + this.baseAngle;
            const flowX = Math.cos(flowA) * this.speed, flowY = Math.sin(flowA) * this.speed;
            const dx = this.x - centerX, dy = this.y - centerY, dist = Math.sqrt(dx * dx + dy * dy) || 1;
            this.vx += (dx / dist) * bass * 0.38;
            if (currentMode === 'BANG') { this.vx += (dx / dist) * 1.8; this.vy += (dy / dist) * 1.8; }
            this.x += flowX + this.vx; this.y += flowY + this.vy; this.vx *= 0.93; this.vy *= 0.93;
            if (this.x < -200 || this.x > bgCanvas.width + 200 || this.y < -200 || this.y > bgCanvas.height + 200) this.init(false);
        }
        draw(hue, bass) {
            const blink = Math.sin(Date.now() * this.flickerS) * 0.15;
            const a = this.alpha + globalVol * 0.2 + bass * 0.45 + blink;
            bgCtx.fillStyle = `hsla(${hue}, 75%, 85%, ${Math.min(1, a)})`;
            bgCtx.beginPath(); bgCtx.arc(this.x, this.y, this.size * (1 + bass * 1.6), 0, Math.PI * 2); bgCtx.fill();
        }
    }

    let nodes = []; let particles = [];

    function setup() {
        syncSizes();
        dataArray = new Uint8Array(256); prevDataArray = new Uint8Array(256);
        nodes = [new SwarmNode(0, canvas.width / 2, canvas.height / 2)];
        particles = Array.from({ length: PARTICLE_COUNT }, () => new BioParticle());
        animate();
    }

    function addEvolutionNode() {
        if (nodes.length >= MAX_NODES) return;
        const parent = nodes[Math.floor(Math.random() * nodes.length)];
        const newNode = new SwarmNode(nodes.length, parent.p.x + 5, parent.p.y + 5);
        newNode.p.vx = (Math.random() - 0.5) * 6; newNode.p.vy = (Math.random() - 0.5) * 6;
        nodes.push(newNode);
    }
    window.addEvolutionNode = addEvolutionNode;

    function syncSizes() {
        const oldW = canvas.width, oldH = canvas.height;
        bgCanvas.width = window.innerWidth; bgCanvas.height = window.innerHeight;
        const rect = mount.getBoundingClientRect();
        
        if (rect && rect.width > 0) {
            canvas.width = uiCanvas.width = rect.width; 
            canvas.height = uiCanvas.height = rect.height;
            
            if (oldW > 0) {
                const cx = canvas.width / 2, cy = canvas.height / 2;
                const oldCX = oldW / 2, oldCY = oldH / 2;
                nodes.forEach(n => {
                    const offX = n.p.x - oldCX, offY = n.p.y - oldCY;
                    n.p.x = cx + offX * (canvas.width / oldW);
                    n.p.y = cy + offY * (canvas.height / oldH);
                    const toffX = n.p.targetX - oldCX, toffY = n.p.targetY - oldCY;
                    n.p.targetX = cx + toffX * (canvas.width / oldW);
                    n.p.targetY = cy + toffY * (canvas.height / oldH);
                });
            }
        }
    }

    function updateMousePos(e) {
        const rect = mount.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        mouse.x = clientX - rect.left; mouse.y = clientY - rect.top;
        rotateY = ((clientX / window.innerWidth) - 0.5) * 8;
        rotateX = ((clientY / window.innerHeight) - 0.5) * -8;
    }

    mount.addEventListener('mousedown', (e) => {
        mouse.down = true; updateMousePos(e);
        let minDist = 120, target = null;
        nodes.forEach(n => { const d = Math.hypot(n.p.x - mouse.x, n.p.y - mouse.y); if (d < minDist) { minDist = d; target = n; } });
        if (target) { dragNode = target; dragNode.isDragging = true; }
    });
    window.addEventListener('mousemove', (e) => { updateMousePos(e); mouse.active = true; });
    window.addEventListener('mouseup', () => { mouse.down = false; if (dragNode) { dragNode.isDragging = false; dragNode = null; } });
    
    mount.addEventListener('touchstart', (e) => {
        if (e.target.tagName !== 'BUTTON') e.preventDefault();
        mouse.down = true; updateMousePos(e);
        let target = null;
        nodes.forEach(n => { if (Math.hypot(n.p.x - mouse.x, n.p.y - mouse.y) < 100) target = n; });
        if (target) { dragNode = target; dragNode.isDragging = true; }
    }, {passive: false});
    window.addEventListener('touchmove', (e) => { if(mouse.down) e.preventDefault(); updateMousePos(e); }, {passive: false});
    window.addEventListener('touchend', () => { mouse.down = false; if (dragNode) { dragNode.isDragging = false; dragNode = null; } });

    // 【修正：track名同期】
    function loadSample(fileName, label) {
        fetch(fileName).then(res => {
            if(!res.ok) throw new Error("CORS or 404");
            return res.arrayBuffer();
        }).then(buffer => {
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            audioCtx.decodeAudioData(buffer, (decoded) => {
                audioBuffer = decoded; displayTitle.innerText = label; 
                if (source) source.stop();
                startPlayback(0); isInitialized = true;
                nodes = [new SwarmNode(0, canvas.width/2, canvas.height/2)]; lastEvolutionTime = 0;
            });
        }).catch(err => {
            console.warn("Sample Load Blocked (CORS/File Protocol). Please use Local Server.");
        });
    }
    window.loadSample = loadSample;

    function startPlayback(offset) {
        source = audioCtx.createBufferSource(); source.buffer = audioBuffer;
        analyser = audioCtx.createAnalyser(); analyser.fftSize = 512;
        source.connect(analyser); analyser.connect(audioCtx.destination);
        source.start(0, offset); startTime = audioCtx.currentTime - offset; isPlaying = true; 
    }

    fileInput.onchange = (e) => {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const reader = new FileReader();
        reader.onload = (ev) => {
            audioCtx.decodeAudioData(ev.target.result, (buf) => {
                audioBuffer = buf; if(source) source.stop(); startPlayback(0); isInitialized = true;
                nodes = [new SwarmNode(0, canvas.width/2, canvas.height/2)]; lastEvolutionTime = 0;
            });
        };
        reader.readAsArrayBuffer(e.target.files[0]);
    };

    aspectBtn.onclick = () => {
        const is169 = mount.classList.contains('ratio-16-9');
        mount.classList.remove('ratio-16-9', 'ratio-4-5');
        mount.classList.add(is169 ? 'ratio-4-5' : 'ratio-16-9');
        
        let animStart = null;
        function step(ts) {
            if(!animStart) animStart = ts;
            syncSizes(); 
            if (ts - animStart < 1300) requestAnimationFrame(step); 
        }
        requestAnimationFrame(step);
    };

    function triggerBang() {
        currentMode = 'BANG';
        if (nodes.length < MAX_NODES) addEvolutionNode();
        nodes.forEach(n => { n.p.vx += (Math.random()-0.5) * 0.35; n.p.vy += (Math.random()-0.5) * 0.35; });
        setTimeout(() => { if (currentMode === 'BANG') currentMode = 'FLOW'; }, 10000);
    }

    function animate() {
        requestAnimationFrame(animate);
        if (isInitialized && isPlaying) { 
            analyser.getByteFrequencyData(dataArray); 
            const current = audioCtx.currentTime - startTime;
            if (current > lastEvolutionTime + EVOLUTION_INTERVAL && nodes.length < MAX_NODES) {
                addEvolutionNode(); lastEvolutionTime = current;
            }
        } else { dataArray.fill(0); }
        
        let s = 0, f = 0, b = 0, p = 0, pIndex = 0;
        for (let i = 0; i < dataArray.length; i++) { 
            s += dataArray[i]; if (i < 15) b += dataArray[i];
            f += Math.max(0, dataArray[i] - prevDataArray[i]); 
            if (dataArray[i] > p) { p = dataArray[i]; pIndex = i; }
        }
        const avg = s / dataArray.length / 255; const bassAvg = b / 15 / 255; const fAvg = f / dataArray.length / 255;
        globalVol = avg; prevDataArray.set(dataArray);

        const hue = (pIndex / 128) * 360 + (Date.now() * 0.003 % 360);
        if (isInitialized) {
            mount.style.setProperty('--frame-glow', `hsla(${hue}, 70%, 70%, ${avg * 0.8})`);
            mount.style.borderColor = `hsla(${hue}, 60%, 80%, ${0.1 + avg * 0.5})`;
            mount.style.boxShadow = `0 0 45px hsla(${hue}, 80%, 50%, ${avg * 0.6}), inset 0 0 100px hsla(${hue}, 80%, 15%, ${bassAvg * 0.4})`;
            vignette.style.transform = `scale(${1 + fAvg * 0.15})`; vignette.style.opacity = 0.4 + avg * 0.6;
        }

        if (currentMode !== 'BANG' && isInitialized && isPlaying && fAvg > 0.24) triggerBang();

        ctx.fillStyle = 'rgba(1, 1, 6, 0.2)'; ctx.fillRect(0, 0, canvas.width, canvas.height);
        bgCtx.clearRect(0, 0, bgCanvas.width, bgCanvas.height);
        particles.forEach(p => { p.update(bassAvg); p.draw(hue, bassAvg); });
        uictx.clearRect(0, 0, uiCanvas.width, uiCanvas.height);
        
        mount.style.transform = `rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;
        nodeDisplay.innerText = `NODES: ${nodes.length}`;

        nodes.forEach((n, i) => { 
            const nodeVol = isInitialized ? dataArray[i % 32] / 255 : 0;
            n.update(nodeVol, fAvg, nodes); n.draw(hue); 
        });
        
        uictx.save();
        for (let i = 0; i < 20; i++) {
            const h = (dataArray[i] / 255) * 55; if (h <= 0) continue;
            uictx.fillStyle = `hsla(${hue}, 10%, 100%, 0.15)`;
            uictx.fillRect((uiCanvas.width/2) + i*14, uiCanvas.height - 90 - h, 2, h);
            uictx.fillRect((uiCanvas.width/2) - i*14, uiCanvas.height - 90 - h, 2, h);
        }
        uictx.restore();
    }

    window.addEventListener('resize', syncSizes);
    setup();
</script>
</body>
</html>