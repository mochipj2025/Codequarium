<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Codequarium - Algorithmic Bio-Fluid Visualizer</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100;300;400;700&family=JetBrains+Mono:wght@100;400&display=swap');

        :root {
            --bg: #000000;
            --accent: #3366ff;
            --text-main: #ffffff;
            --text-dim: rgba(255, 255, 255, 0.5);
            --card-bg: rgba(255, 255, 255, 0.02);
            --frame-glow: rgba(51, 102, 255, 0);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            background-color: var(--bg);
            color: var(--text-main);
            font-family: 'Inter', sans-serif;
            line-height: 2.0; /* 行間を広げてさらに美しく */
            overflow-x: hidden;
            width: 100%;
            touch-action: manipulation;
            -webkit-text-size-adjust: 100%;
        }

        /* --- タイポグラフィ最適化 --- */
        h1, h2, h3 { 
            text-wrap: balance;
            word-break: keep-all; 
            letter-spacing: 0.4em;
            text-transform: uppercase;
            font-weight: 100;
        }
        p { 
            text-wrap: pretty;
            max-width: 600px;
            color: var(--text-dim);
            font-weight: 300;
            margin-bottom: 2rem;
        }
        .keep-together { display: inline-block; white-space: nowrap; }

        /* --- エフェクトレイヤー --- */
        #vignette {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 30%, rgba(0,0,0,1) 160%);
            z-index: 5; pointer-events: none;
        }

        #background-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 1; pointer-events: none;
        }

        /* --- レイアウト構造 --- */
        section { padding: 140px 10%; position: relative; z-index: 20; }
        .container { max-width: 1100px; margin: 0 auto; }

        h1 { font-size: clamp(2.4rem, 8vw, 6rem); margin-bottom: 20px; line-height: 1.1; }
        .hero-sub { font-size: 0.7rem; color: var(--accent); letter-spacing: 0.5em; margin-bottom: 40px; text-transform: uppercase; }

        /* --- Hero --- */
        #hero {
            min-height: 110vh; /* 少し高さを出してゆとりを */
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            padding: 100px 0; overflow: hidden;
        }

        #visualizer-mount {
            position: relative;
            z-index: 10;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.15);
            background: rgba(1, 1, 4, 0.98);
            border-radius: 8px; /* 角を少し丸めて柔らかく */
            box-shadow: 0 0 80px var(--frame-glow);
            transform-style: preserve-3d;
            transition: width 0.8s cubic-bezier(0.16, 1, 0.3, 1), height 0.8s cubic-bezier(0.16, 1, 0.3, 1), transform 0.1s ease-out;
            margin: 0 auto;
        }

        #visualizer-mount.ratio-16-9 { width: 85vw; height: calc(85vw * 9 / 16); max-width: 1100px; max-height: 620px; }
        #visualizer-mount.ratio-4-5 { width: 75vw; height: calc(75vw * 5 / 4); max-width: 550px; max-height: 700px; }

        @media (max-width: 600px) {
            #hero { padding: 60px 0; }
            /* スマホ：画面端に「呼吸できる余白」を確保 */
            #visualizer-mount.ratio-16-9 { width: 92vw; height: calc(92vw * 10 / 16); }
            #visualizer-mount.ratio-4-5 { width: 90vw; height: 125vw; } 
            
            section { padding: 100px 24px; }
            .hero-controls { gap: 10px; margin-top: 40px; }
            .btn-zen { padding: 12px 14px; font-size: 8px; letter-spacing: 0.1em; }
        }

        #fluid-engine {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            filter: blur(20px) contrast(120) brightness(1.1);
            pointer-events: none; z-index: 2;
        }

        canvas { display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; }

        .hero-controls {
            margin-top: 50px; display: flex; gap: 12px; flex-wrap: wrap; justify-content: center; z-index: 30;
            max-width: 95vw;
        }

        /* --- UI Components --- */
        .guide-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 50px; margin-top: 80px; }
        .guide-item { padding: 30px; border-left: 1px solid rgba(255,255,255,0.08); transition: 0.4s; }
        .guide-item:hover { border-left-color: var(--accent); background: rgba(255,255,255,0.02); }
        .guide-num { font-family: 'JetBrains+Mono', monospace; color: var(--accent); font-size: 0.8rem; margin-bottom: 20px; display: block; opacity: 0.8; }
        .guide-item h3 { font-size: 0.8rem; margin-bottom: 15px; color: #fff; letter-spacing: 0.2em; line-height: 1.5; }
        .guide-item p { font-size: 0.85rem; line-height: 1.8; margin-bottom: 0; }

        .btn-zen {
            font-family: 'JetBrains+Mono', monospace; font-size: 9px; letter-spacing: 0.25em; text-transform: uppercase;
            color: var(--text-dim); background: transparent; border: 1px solid rgba(255, 255, 255, 0.12);
            padding: 14px 22px; cursor: pointer; transition: 0.3s;
            outline: none; -webkit-tap-highlight-color: transparent;
            border-radius: 2px;
        }
        .btn-zen:hover { color: #fff; border-color: var(--accent); background: rgba(51, 102, 255, 0.1); }
        .btn-zen.active { border-color: var(--accent); color: #fff; background: rgba(51, 102, 255, 0.08); }

        .mystic-link {
            display: inline-block; margin-top: 60px; padding: 22px 55px; background: #fff; color: #000;
            text-decoration: none; font-weight: 700; text-transform: uppercase; letter-spacing: 0.3em; font-size: 0.75rem;
            transition: 0.4s; border-radius: 2px;
        }
        .mystic-link:hover { background: var(--accent); color: white; transform: translateY(-5px); box-shadow: 0 10px 40px rgba(51, 102, 255, 0.3); }

        .mount-hud {
            position: absolute; top: 18px; left: 24px; right: 24px;
            display: flex; justify-content: space-between;
            z-index: 20; pointer-events: none;
            font-family: 'JetBrains+Mono', monospace; font-size: 8px; opacity: 0.6;
            letter-spacing: 0.2em;
        }
        
        #ui-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 5; pointer-events: none; }
    </style>
</head>
<body>

<div id="vignette"></div>
<canvas id="background-layer"></canvas>

<div id="hero">
    <div class="container" style="text-align: center; margin-bottom: 20px;">
        <div class="hero-sub">The Coding Aquarium Project / <span class="keep-together">コードで描かれた水槽</span></div>
        <h1>Codequarium</h1>
        <p style="margin: 0 auto 40px; max-width: 580px;">
            <span class="keep-together">計算が呼吸し、</span><span class="keep-together">旋律が鼓動へと変わる。</span><br>
            <span class="keep-together">コードで描かれた</span><span class="keep-together">深淵の生態系。</span>
        </p>
    </div>

    <!-- メインマウント -->
    <div id="visualizer-mount" class="ratio-16-9">
        <div class="mount-hud">
            <div id="display-title">Bio-Void Standby</div>
            <div id="node-count-display">NODES: 1</div>
        </div>
        <canvas id="ui-canvas"></canvas>
        <div id="fluid-engine"><canvas id="art-canvas"></canvas></div>
    </div>

    <!-- コントロール -->
    <div class="hero-controls">
        <button class="btn-zen active" id="play-pause-btn" onclick="togglePlayback()">Play</button>
        <button class="btn-zen" onclick="loadSample('track1.mp3', 'コーヒーの湯気')">Coffee Steam</button>
        <button class="btn-zen" onclick="loadSample('track2.mp3', '雨上がりブレンド')">After Rain</button>
        <button class="btn-zen" onclick="loadSample('track3.mp3', '午後のカップと君')">Afternoon Cup</button>
        <label class="btn-zen">Import MP3 <input type="file" id="file-input" accept=".mp3,audio/mpeg,audio/mp3,audio/*" style="display:none;"></label>
        <button class="btn-zen" id="aspect-btn" style="border-color: rgba(100,150,255,0.4);">Change Layout</button>
    </div>
</div>

<section id="how-to">
    <div class="container">
        <h2>How to Interact / <span class="keep-together">操作方法</span></h2>
        <div class="guide-grid">
            <div class="guide-item">
                <span class="guide-num">01</span>
                <h3>Invoke Sound / <span class="keep-together">音楽を呼び覚ます</span></h3>
                <p>
                    <span class="keep-together">ライブラリから曲を選び、</span><span class="keep-together">静寂に包まれた水槽に</span><span class="keep-together">生命を宿してください。</span><span class="keep-together">iPhoneの方は「ファイル」アプリ内の</span><span class="keep-together">曲が選択可能です。</span>
                </p>
            </div>
            <div class="guide-item">
                <span class="guide-num">02</span>
                <h3>Manipulate Fluid / <span class="keep-together">流体をかき混ぜる</span></h3>
                <p>
                    <span class="keep-together">画面内のスライムを</span><span class="keep-together">ドラッグしてかき混ぜます。</span><span class="keep-together">物理演算による粘性と、</span><span class="keep-together">放した瞬間の</span><span class="keep-together">慣性を体験できます。</span>
                </p>
            </div>
            <div class="guide-item">
                <span class="guide-num">03</span>
                <h3>Observe Evolution / <span class="keep-together">進化を観察する</span></h3>
                <p>
                    <span class="keep-together">旋律のエネルギーが高まると、</span><span class="keep-together">核は最大16個まで自己分裂し、</span><span class="keep-together">それぞれの個体が独立した</span><span class="keep-together">意思を持つかのように泳ぎ回ります。</span>
                </p>
            </div>
            <div class="guide-item">
                <span class="guide-num">04</span>
                <h3>Feel the Recovery / <span class="keep-together">静寂への回帰</span></h3>
                <p>
                    <span class="keep-together">マウスを離すと、</span><span class="keep-together">空間の傾きや粒子への干渉は</span><span class="keep-together">ゆっくりと収束し、世界は</span><span class="keep-together">元の穏やかな静止状態へと戻ります。</span>
                </p>
            </div>
        </div>
    </div>
</section>

<section id="footer-section" style="text-align: center; border-top: 1px solid rgba(255,255,255,0.05);">
    <div class="container">
        <h2>Enter the Void / <span class="keep-together">深淵へ</span></h2>
        <p style="margin: 0 auto 10px;">
            <span class="keep-together">Codequariumは、音楽と計算が</span><span class="keep-together">融合する実験的なデジタル水槽です。</span>
        </p>
        <p id="error-notice" style="font-size: 11px; opacity: 0.5; margin-bottom: 50px;">
            <span class="keep-together">※スマホでの再生は、画面を</span><span class="keep-together">一度タップした後に可能になります。</span>
        </p>
        <a href="https://www.threads.net/@hogushiya_kida?xmt=AQF0jg1JRo6B5FOakS_Gv36JaTHkwzBeYu6f729XkxglZCo" class="mystic-link" target="_blank">Connect on Threads / <span class="keep-together">Threadsで繋がる</span></a>
    </div>
</section>

<footer style="padding: 100px 60px; text-align: center; font-size: 9px; opacity: 0.3; letter-spacing: 0.6em;">
    &copy; 2025 CODEQUARIUM PROJECT. CRAFTED BY CODE.
</footer>

<script>
    /**
     * CODEQUARIUM CORE ENGINE - Spacing & Stability Fixed
     */
    const bgCanvas = document.getElementById('background-layer');
    const canvas = document.getElementById('art-canvas');
    const uiCanvas = document.getElementById('ui-canvas');
    const bgCtx = bgCanvas.getContext('2d');
    const ctx = canvas.getContext('2d');
    const uictx = uiCanvas.getContext('2d');
    const mount = document.getElementById('visualizer-mount');
    const vignette = document.getElementById('vignette');
    const nodeDisplay = document.getElementById('node-count-display');
    const displayTitle = document.getElementById('display-title');
    const fileInput = document.getElementById('file-input');
    const aspectBtn = document.getElementById('aspect-btn');
    const playPauseBtn = document.getElementById('play-pause-btn');

    let audioCtx, analyser, dataArray, prevDataArray, source, audioBuffer;
    let isInitialized = false, isPlaying = false;
    let startTime = 0, pauseOffset = 0;
    let currentMode = 'FLOW', globalVol = 0;
    
    let mouse = { x: 0, y: 0, globalX: 0, globalY: 0, active: false, down: false, influence: 0 };
    let dragNode = null; 
    let rotateX = 0, rotateY = 0;
    let dpr = window.devicePixelRatio || 1;

    const MAX_NODES = 16; 
    const PARTICLE_COUNT = 150; 
    let lastEvolutionTime = 0;
    const EVOLUTION_INTERVAL = 12;

    const FRICTION = 0.993; 
    const VISCOSITY = 0.012; 
    const BASE_SPEED_LIMIT = 0.45;

    function wakeAudio() {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if (audioCtx.state === 'suspended') audioCtx.resume();
    }

    class SwarmNode {
        constructor(id, x, y) {
            this.id = id; this.x = x; this.y = y; this.vx = 0; this.vy = 0;
            this.targetX = x; this.targetY = y; this.radius = 12;
            this.noiseSeedX = Math.random() * 2000; this.noiseSeedY = Math.random() * 2000;
            this.isDragging = false;
        }
        update(nodeVol, flux, nodes) {
            const rect = mount.getBoundingClientRect();
            const logicalW = rect.width; const logicalH = rect.height;

            if (this.isDragging) {
                this.x = mouse.x; this.y = mouse.y;
                this.targetX = mouse.x; this.targetY = mouse.y;
            } else {
                const t = Date.now() * 0.00005;
                let tx = (logicalW/2) + Math.sin(t * (0.6 + this.id * 0.08) + this.noiseSeedX) * (logicalW * 0.35);
                let ty = (logicalH/2) + Math.cos(t * (0.5 + this.id * 0.12) + this.noiseSeedY) * (logicalH * 0.35);
                
                if (mouse.influence > 0.01) {
                    const dx = mouse.x - this.x, dy = mouse.y - this.y;
                    const d = Math.sqrt(dx * dx + dy * dy) || 1;
                    if (d < 300) { tx += (dx / d) * (55 * mouse.influence); ty += (dy / d) * (55 * mouse.influence); }
                }

                nodes.forEach(other => {
                    if (other === this) return;
                    const dx = other.x - this.x, dy = other.y - this.y;
                    const dist = Math.sqrt(dx*dx + dy*dy) || 5;
                    const minDist = (this.radius + other.radius) * 1.5;
                    if (dist < minDist) { this.vx -= (dx / dist) * 0.025; this.vy -= (dy / dist) * 0.025; }
                });

                this.vx += (tx - this.x) * VISCOSITY; this.vy += (ty - this.y) * VISCOSITY;
                const limit = BASE_SPEED_LIMIT + flux * 0.6;
                const speed = Math.sqrt(this.vx*this.vx + this.vy*this.vy) || 0.01;
                if (speed > limit) { this.vx = (this.vx/speed)*limit; this.vy = (this.vy/speed)*limit; }
                this.x += this.vx; this.y += this.vy;
                this.vx *= FRICTION; this.vy *= FRICTION;
            }

            const pad = this.radius + 10;
            if (this.x < pad) { this.vx = Math.abs(this.vx) * 0.6; this.x = pad; }
            if (this.x > logicalW - pad) { this.vx = -Math.abs(this.vx) * 0.6; this.x = logicalW - pad; }
            if (this.y < pad) { this.vy = Math.abs(this.vy) * 0.6; this.y = pad; }
            if (this.y > logicalH - pad) { this.vy = -Math.abs(this.vy) * 0.6; this.y = logicalH - pad; }
            
            const targetR = 30 + nodeVol * 90 + flux * 150;
            this.radius += (targetR - this.radius) * (targetR > this.radius ? 0.3 : 0.08);
        }
        draw(hue) {
            if (!isFinite(this.x) || !isFinite(this.y)) return;
            const g = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.radius);
            const intensity = (this.isDragging || currentMode === 'BANG') ? 1.0 : 0.75;
            g.addColorStop(0, `hsla(${hue}, 80%, 96%, ${intensity})`); 
            g.addColorStop(0.25, `hsla(${hue}, 70%, 55%, 0.65)`);
            g.addColorStop(0.75, `hsla(${hue}, 90%, 12%, 0.2)`);
            g.addColorStop(1, 'transparent');
            ctx.fillStyle = g; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill();
        }
    }

    class BioParticle {
        constructor() { this.init(true); }
        init(randomPos = false) {
            const w = bgCanvas.width/dpr, h = bgCanvas.height/dpr;
            if (randomPos) { this.x = Math.random() * w; this.y = Math.random() * h; } 
            else { const a = Math.random()*Math.PI*2, d = Math.random()*150; this.x = (w/2) + Math.cos(a)*d; this.y = (h/2) + Math.sin(a)*d; }
            this.z = Math.random() * 2 + 0.5; this.baseAngle = Math.random() * Math.PI * 2;
            this.speed = (Math.random() * 0.14 + 0.06) / this.z; this.size = Math.random() * 1.6 + 0.6;
            this.alpha = Math.random() * 0.25 + 0.12; this.flickerS = Math.random() * 0.03 + 0.01; this.vx = 0; this.vy = 0;
        }
        update(bass) {
            const w = bgCanvas.width/dpr, h = bgCanvas.height/dpr;
            const cx = w / 2, cy = h / 2, t = Date.now() * 0.001;
            const flowA = t * (0.045 / this.z) + this.baseAngle;
            this.x += Math.cos(flowA) * this.speed + this.vx; this.y += Math.sin(flowA) * this.speed + this.vy;
            const dx = this.x - cx, dy = this.y - cy, dist = Math.sqrt(dx*dx + dy*dy) || 1;
            this.vx += (dx / dist) * bass * 0.45; if (currentMode === 'BANG') { this.vx += (dx/dist)*2.5; }
            if (mouse.influence > 0.01) {
                const mdx = this.x - mouse.globalX, mdy = this.y - mouse.globalY;
                const mdist = Math.sqrt(mdx*mdx + mdy*mdy) || 1;
                if (mdist < 260) { const f = (1 - mdist/260) * 3.5 * mouse.influence; this.vx += (mdx/mdist)*f; this.vy += (mdy/mdist)*f; }
            }
            this.vx *= 0.92; this.vy *= 0.92;
            if (this.x < -150 || this.x > w + 150 || this.y < -150 || this.y > h + 150) this.init(false);
        }
        draw(hue, bass) {
            const a = this.alpha + globalVol * 0.25 + bass * 0.45 + Math.sin(Date.now() * this.flickerS) * 0.1;
            bgCtx.fillStyle = `hsla(${hue}, 75%, 90%, ${Math.min(1, a)})`;
            bgCtx.beginPath(); bgCtx.arc(this.x, this.y, this.size * (1 + bass * 1.8), 0, Math.PI * 2); bgCtx.fill();
        }
    }

    let nodes = []; let particles = [];

    function setup() {
        syncSizes();
        dataArray = new Uint8Array(256); prevDataArray = new Uint8Array(256);
        const rect = mount.getBoundingClientRect();
        nodes = [new SwarmNode(0, rect.width / 2, rect.height / 2)];
        particles = Array.from({ length: PARTICLE_COUNT }, () => new BioParticle());
        animate();
    }

    function syncSizes() {
        dpr = window.devicePixelRatio || 1;
        const rect = mount.getBoundingClientRect();
        bgCanvas.width = window.innerWidth * dpr; bgCanvas.height = window.innerHeight * dpr;
        bgCanvas.style.width = window.innerWidth + 'px'; bgCanvas.style.height = window.innerHeight + 'px';
        bgCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
        [canvas, uiCanvas].forEach(c => {
            c.width = rect.width * dpr; c.height = rect.height * dpr;
            c.style.width = rect.width + 'px'; c.style.height = rect.height + 'px';
        });
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        uictx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }

    function updateMousePos(e) {
        const rect = mount.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        mouse.x = clientX - rect.left; mouse.y = clientY - rect.top;
        mouse.globalX = clientX; mouse.globalY = clientY;
        rotateY = ((clientX / window.innerWidth) - 0.5) * 8; rotateX = ((clientY / window.innerHeight) - 0.5) * -8;
    }

    mount.addEventListener('mousedown', (e) => { wakeAudio(); mouse.down = true; updateMousePos(e); let target = null; nodes.forEach(n => { if (Math.hypot(n.x - mouse.x, n.y - mouse.y) < 120) target = n; }); if (target) { dragNode = target; dragNode.isDragging = true; } });
    window.addEventListener('mousemove', (e) => { updateMousePos(e); mouse.active = true; });
    window.addEventListener('mouseup', () => { mouse.down = false; if (dragNode) { dragNode.isDragging = false; dragNode = null; } });
    mount.addEventListener('mouseleave', () => { mouse.active = false; });
    mount.addEventListener('touchstart', (e) => { wakeAudio(); if (e.target.tagName !== 'BUTTON') e.preventDefault(); mouse.down = true; mouse.active = true; updateMousePos(e); let target = null; nodes.forEach(n => { if (Math.hypot(n.x - mouse.x, n.y - mouse.y) < 100) target = n; }); if (target) { dragNode = target; dragNode.isDragging = true; } }, {passive: false});
    window.addEventListener('touchmove', (e) => { if(mouse.down) e.preventDefault(); updateMousePos(e); }, {passive: false});
    window.addEventListener('touchend', () => { mouse.down = false; mouse.active = false; if (dragNode) { dragNode.isDragging = false; dragNode = null; } });

    function startPlayback(offset) {
        if (!audioBuffer) return;
        wakeAudio();
        if (!analyser) { analyser = audioCtx.createAnalyser(); analyser.fftSize = 512; analyser.connect(audioCtx.destination); }
        if (source) { try { source.stop(); } catch(e) {} source.disconnect(); }
        source = audioCtx.createBufferSource(); source.buffer = audioBuffer; source.connect(analyser); source.start(0, offset);
        startTime = audioCtx.currentTime - offset; isPlaying = true;
        playPauseBtn.innerText = "Pause"; playPauseBtn.classList.add('active');
    }

    function togglePlayback() { wakeAudio(); if (!audioBuffer) return; if (isPlaying) { pauseOffset = audioCtx.currentTime - startTime; if (source) source.stop(); isPlaying = false; playPauseBtn.innerText = "Play"; playPauseBtn.classList.remove('active'); } else { startPlayback(pauseOffset % audioBuffer.duration); } }

    function loadSample(fileName, label) {
        wakeAudio(); if (displayTitle) displayTitle.innerText = "Loading...";
        fetch(fileName).then(res => { if(!res.ok) throw new Error(); return res.arrayBuffer(); }).then(buffer => {
            audioCtx.decodeAudioData(buffer, (decoded) => {
                audioBuffer = decoded; if (displayTitle) displayTitle.innerText = label; 
                pauseOffset = 0; startPlayback(0); isInitialized = true;
                const rect = mount.getBoundingClientRect(); nodes = [new SwarmNode(0, rect.width/2, rect.height/2)]; lastEvolutionTime = 0;
            });
        }).catch(err => { if (displayTitle) displayTitle.innerText = "Load Error"; });
    }
    window.loadSample = loadSample; window.togglePlayback = togglePlayback;

    fileInput.onchange = (e) => {
        if (!e.target.files[0]) return;
        wakeAudio(); if (displayTitle) displayTitle.innerText = "Reading...";
        const reader = new FileReader();
        reader.onload = (ev) => {
            audioCtx.decodeAudioData(ev.target.result, (buf) => {
                audioBuffer = buf; if (displayTitle) displayTitle.innerText = e.target.files[0].name;
                pauseOffset = 0; startPlayback(0); isInitialized = true;
                const rect = mount.getBoundingClientRect(); nodes = [new SwarmNode(0, rect.width/2, rect.height/2)]; lastEvolutionTime = 0;
            });
        };
        reader.readAsArrayBuffer(e.target.files[0]);
    };

    aspectBtn.onclick = () => {
        const is169 = mount.classList.contains('ratio-16-9');
        mount.classList.remove('ratio-16-9', 'ratio-4-5'); mount.classList.add(is169 ? 'ratio-4-5' : 'ratio-16-9');
        let animStart = null;
        function step(ts) { if(!animStart) animStart = ts; syncSizes(); if (ts - animStart < 900) requestAnimationFrame(step); }
        requestAnimationFrame(step);
    };

    function animate() {
        requestAnimationFrame(animate);
        if (mouse.active) { mouse.influence += (1 - mouse.influence) * 0.12; } 
        else { mouse.influence += (0 - mouse.influence) * 0.06; rotateX *= 0.94; rotateY *= 0.94; }
        if (isInitialized && isPlaying && analyser) { 
            analyser.getByteFrequencyData(dataArray); 
            const current = audioCtx.currentTime - startTime;
            if (current > lastEvolutionTime + EVOLUTION_INTERVAL && nodes.length < MAX_NODES) {
                const p = nodes[Math.floor(Math.random()*nodes.length)];
                nodes.push(new SwarmNode(nodes.length, p.x+5, p.y+5));
                lastEvolutionTime = current;
            }
            if (current >= audioBuffer.duration) { isPlaying = false; playPauseBtn.innerText = "Play"; pauseOffset = 0; }
        } else { if (dataArray) dataArray.fill(0); }
        
        let s = 0, f = 0, b = 0, pIndex = 0;
        if (dataArray) {
            for (let i = 0; i < dataArray.length; i++) { s += dataArray[i]; if (i < 15) b += dataArray[i]; f += Math.max(0, dataArray[i] - (prevDataArray ? prevDataArray[i] : 0)); if (dataArray[i] > (dataArray[pIndex] || 0)) { pIndex = i; } }
            const avg = s / dataArray.length / 255; const bassAvg = b / 15 / 255; const fAvg = f / dataArray.length / 255;
            globalVol = avg; if (!prevDataArray) prevDataArray = new Uint8Array(256); prevDataArray.set(dataArray);
            const hue = (pIndex / 128) * 360 + (Date.now() * 0.003 % 360);
            if (isInitialized) {
                mount.style.setProperty('--frame-glow', `hsla(${hue}, 70%, 70%, ${avg * 0.9})`);
                mount.style.borderColor = `hsla(${hue}, 60%, 80%, ${0.2 + avg * 0.5})`;
                vignette.style.opacity = 0.4 + avg * 0.6;
            }
            if (currentMode !== 'BANG' && isInitialized && isPlaying && fAvg > 0.22) { currentMode = 'BANG'; setTimeout(() => currentMode = 'FLOW', 8000); }
            
            const rect = mount.getBoundingClientRect();
            ctx.clearRect(0,0,rect.width, rect.height);
            bgCtx.clearRect(0,0,window.innerWidth, window.innerHeight);
            uictx.clearRect(0,0,rect.width, rect.height);
            
            particles.forEach(p => { p.update(bassAvg); p.draw(hue, bassAvg); });
            mount.style.transform = `rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;
            nodeDisplay.innerText = `NODES: ${nodes.length}`;
            nodes.forEach((n, i) => { n.update(isInitialized ? dataArray[i%32]/255 : 0, fAvg, nodes); n.draw(hue); });
            
            // --- イコライザー修正：HUDの横に絶妙な余白で配置 ---
            uictx.save();
            const barCount = 18, barGap = 12, barW = 1.2;
            const startX = (rect.width / 2) - (barCount * barGap / 2);
            const baselineY = 48; 
            for (let i = 0; i < barCount; i++) {
                const h = (dataArray[i] / 255) * 35; if (h <= 0) continue;
                uictx.fillStyle = `hsla(${hue}, 80%, 90%, 0.45)`;
                uictx.fillRect(startX + i * barGap, baselineY, barW, h);
            }
            uictx.restore();
        }
    }
    window.addEventListener('resize', syncSizes);
    setup();
</script>
</body>
</html>

