<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Codequarium - Algorithmic Bio-Fluid Visualizer</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100;300;400;700&family=JetBrains+Mono:wght@100;400&display=swap');

        :root {
            --bg: #000000;
            --accent: #3366ff;
            --text-main: #ffffff;
            --text-dim: rgba(255, 255, 255, 0.5);
            --card-bg: rgba(255, 255, 255, 0.02);
            --frame-glow: rgba(51, 102, 255, 0);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            background-color: var(--bg);
            color: var(--text-main);
            font-family: 'Inter', sans-serif;
            line-height: 1.8;
            overflow-x: hidden;
            width: 100%;
        }

        /* --- タイポグラフィ最適化（孤立行防止） --- */
        h1, h2, h3 { 
            text-wrap: balance;
            word-break: keep-all; 
            overflow-wrap: anywhere;
            letter-spacing: 0.3em;
            text-transform: uppercase;
            font-weight: 100;
        }
        p { 
            text-wrap: pretty;
            max-width: 700px;
            color: var(--text-dim);
            font-weight: 300;
        }
        .keep-together { display: inline-block; }

        /* --- 背景・ビネット --- */
        #vignette {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 30%, rgba(0,0,0,0.95) 150%);
            z-index: 5; pointer-events: none;
        }

        #background-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 1; pointer-events: none;
        }

        /* --- セクション構造 --- */
        section { padding: 100px 8%; position: relative; z-index: 20; }
        .container { max-width: 1100px; margin: 0 auto; }

        h1 { font-size: clamp(2.2rem, 8vw, 5.5rem); margin-bottom: 10px; line-height: 1.1; }
        .hero-sub { font-size: 0.7rem; color: var(--accent); letter-spacing: 0.4em; margin-bottom: 30px; }

        /* --- Hero --- */
        #hero {
            min-height: 100vh;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            padding: 40px 0; overflow: hidden;
        }

        #visualizer-mount {
            position: relative;
            z-index: 10;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.12);
            background: rgba(1, 1, 4, 0.98);
            border-radius: 4px;
            box-shadow: 0 0 60px var(--frame-glow);
            transform-style: preserve-3d;
            transition: width 1.2s cubic-bezier(0.16, 1, 0.3, 1), height 1.2s cubic-bezier(0.16, 1, 0.3, 1), transform 0.1s ease-out;
            margin: 0 auto;
        }

        #visualizer-mount.ratio-16-9 { width: 90vw; height: calc(90vw * 9 / 16); max-width: 1100px; max-height: 620px; }
        #visualizer-mount.ratio-4-5 { width: 85vw; height: calc(85vw * 5 / 4); max-width: 600px; max-height: 750px; }

        #fluid-engine {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            filter: blur(24px) contrast(95) brightness(1.2);
            pointer-events: none; z-index: 2;
        }

        canvas { display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; }

        .hero-controls {
            margin-top: 30px; display: flex; gap: 10px; flex-wrap: wrap; justify-content: center; z-index: 30;
            max-width: 95vw;
        }

        /* --- UI Components --- */
        .guide-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); gap: 30px; margin-top: 50px; }
        .guide-item { padding: 25px; border-left: 1px solid rgba(255,255,255,0.1); transition: 0.3s; }
        .guide-item:hover { border-left-color: var(--accent); background: rgba(255,255,255,0.01); }
        .guide-num { font-family: 'JetBrains+Mono', monospace; color: var(--accent); font-size: 0.8rem; margin-bottom: 15px; display: block; opacity: 0.8; }
        .guide-item h3 { font-size: 0.75rem; margin-bottom: 12px; color: #fff; letter-spacing: 0.15em; line-height: 1.4; }
        .guide-item p { font-size: 0.8rem; }

        .feature-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 25px; margin-top: 60px; }
        .feature-card { background: var(--card-bg); padding: 35px; border: 1px solid rgba(255, 255, 255, 0.04); transition: 0.4s; }
        .feature-card:hover { border-color: var(--accent); transform: translateY(-8px); background: rgba(51, 102, 255, 0.02); }
        .feature-card h3 { margin-bottom: 15px; font-size: 0.85rem; color: #fff; }

        .btn-zen {
            font-family: 'JetBrains+Mono', monospace; font-size: 8px; letter-spacing: 0.2em; text-transform: uppercase;
            color: var(--text-dim); background: transparent; border: 1px solid rgba(255, 255, 255, 0.12);
            padding: 12px 20px; cursor: pointer; transition: 0.3s;
            outline: none;
        }
        .btn-zen:hover { color: #fff; border-color: var(--accent); background: rgba(51, 102, 255, 0.08); }
        .btn-zen.active { border-color: var(--accent); color: #fff; background: rgba(51, 102, 255, 0.05); }

        .mystic-link {
            display: inline-block; margin-top: 40px; padding: 18px 45px; background: #fff; color: #000;
            text-decoration: none; font-weight: 700; text-transform: uppercase; letter-spacing: 0.2em; font-size: 0.75rem;
            transition: 0.3s;
        }
        .mystic-link:hover { background: var(--accent); color: white; transform: scale(1.05); }

        .mount-hud {
            position: absolute; top: 15px; left: 20px; right: 20px;
            display: flex; justify-content: space-between;
            z-index: 20; pointer-events: none;
            font-family: 'JetBrains+Mono', monospace; font-size: 7px; opacity: 0.5;
        }
        
        #ui-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 5; pointer-events: none; }

        @media (max-width: 600px) {
            #visualizer-mount.ratio-16-9 { width: 95vw; height: calc(95vw * 9 / 16); }
            #visualizer-mount.ratio-4-5 { width: 92vw; height: 115vw; }
            section { padding: 60px 25px; }
            .btn-zen { padding: 8px 14px; font-size: 7px; }
        }
    </style>
</head>
<body>

<div id="vignette"></div>
<canvas id="background-layer"></canvas>

<div id="hero">
    <div class="container" style="text-align: center;">
        <div class="hero-sub">The Coding Aquarium Project / <span class="keep-together">コードで描かれた水槽</span></div>
        <h1>Codequarium</h1>
        <p style="margin: 0 auto 35px; max-width: 550px;">
            <span class="keep-together">計算が呼吸し、</span><span class="keep-together">旋律が鼓動へと変わる。</span><br>
            <span class="keep-together">コードで描かれた</span><span class="keep-together">深淵の生態系。</span>
        </p>
    </div>

    <!-- メインマウント -->
    <div id="visualizer-mount" class="ratio-16-9">
        <div class="mount-hud">
            <div id="display-title">Bio-Void Standby</div>
            <div id="node-count-display">NODES: 1</div>
        </div>
        <canvas id="ui-canvas"></canvas>
        <div id="fluid-engine"><canvas id="art-canvas"></canvas></div>
    </div>

    <!-- コントロール -->
    <div class="hero-controls">
        <button class="btn-zen active" id="play-pause-btn" onclick="togglePlayback()">Play</button>
        <button class="btn-zen" onclick="loadSample('track1.mp3', 'コーヒーの湯気')">Coffee Steam</button>
        <button class="btn-zen" onclick="loadSample('track2.mp3', '雨上がりブレンド')">After Rain</button>
        <button class="btn-zen" onclick="loadSample('track3.mp3', '午後のカップと君')">Afternoon Cup</button>
        <label class="btn-zen">Import MP3 <input type="file" id="file-input" accept="audio/*" style="display:none;"></label>
        <button class="btn-zen" id="aspect-btn" style="border-color: rgba(100,150,255,0.4);">Change Layout</button>
    </div>
</div>

<section id="how-to">
    <div class="container">
        <h2>How to Interact / <span class="keep-together">操作方法</span></h2>
        <div class="guide-grid">
            <div class="guide-item">
                <span class="guide-num">01</span>
                <h3>Invoke Sound / <span class="keep-together">音楽を呼び覚ます</span></h3>
                <p>
                    <span class="keep-together">ライブラリから</span><span class="keep-together">曲を選ぶか、</span><span class="keep-together">手持ちのファイルを</span><span class="keep-together">読み込ませることで、</span><span class="keep-together">静寂に包まれた</span><span class="keep-together">水槽が生命を</span><span class="keep-together">宿し始めます。</span>
                </p>
            </div>
            <div class="guide-item">
                <span class="guide-num">02</span>
                <h3>Manipulate Fluid / <span class="keep-together">流体をかき混ぜる</span></h3>
                <p>
                    <span class="keep-together">画面内のスライムを</span><span class="keep-together">ドラッグして</span><span class="keep-together">かき混ぜてください。</span><span class="keep-together">物理演算による</span><span class="keep-together">粘性と、</span><span class="keep-together">放した瞬間の</span><span class="keep-together">慣性を体験できます。</span>
                </p>
            </div>
            <div class="guide-item">
                <span class="guide-num">03</span>
                <h3>Observe Evolution / <span class="keep-together">進化を観察する</span></h3>
                <p>
                    <span class="keep-together">音楽のエネルギーが</span><span class="keep-together">高まると、</span><span class="keep-together">核は最大16個まで</span><span class="keep-together">自己分裂します。</span><span class="keep-together">それぞれの個体が</span><span class="keep-together">独立した意思を</span><span class="keep-together">持つかのように</span><span class="keep-together">泳ぎ回ります。</span>
                </p>
            </div>
            <div class="guide-item">
                <span class="guide-num">04</span>
                <h3>Feel the Recovery / <span class="keep-together">静寂への回帰</span></h3>
                <p>
                    <span class="keep-together">マウスを離すと、</span><span class="keep-together">空間の傾きや</span><span class="keep-together">粒子への干渉は</span><span class="keep-together">ゆっくりと収束し、</span><span class="keep-together">世界は元の</span><span class="keep-together">穏やかな状態へと</span><span class="keep-together">戻ります。</span>
                </p>
            </div>
        </div>
    </div>
</section>

<section id="features" style="background: rgba(255,255,255,0.01);">
    <div class="container">
        <h2>System Ecosystem / <span class="keep-together">生態系システム</span></h2>
        <div class="feature-grid">
            <div class="feature-card">
                <h3>Bio-Fluid Physics / <span class="keep-together">生物流体物理学</span></h3>
                <p><span class="keep-together">FFT周波数解析と</span><span class="keep-together">メタボール・フィルターにより、</span><span class="keep-together">軽量でありながら</span><span class="keep-together">重厚な流体質感を</span><span class="keep-together">ブラウザ上で</span><span class="keep-together">実現しました。</span></p>
            </div>
            <div class="feature-card">
                <h3>Spectral Synthesis / <span class="keep-together">スペクトル合成</span></h3>
                <p><span class="keep-together">音の高さ（ピッチ）を</span><span class="keep-together">解析し、</span><span class="keep-together">空間の色温度を</span><span class="keep-together">リアルタイムに制御。</span><span class="keep-together">音の感情を色彩として</span><span class="keep-together">可視化します。</span></p>
            </div>
            <div class="feature-card">
                <h3>Vortex Circulation / <span class="keep-together">渦状循環</span></h3>
                <p><span class="keep-together">背景に漂う粒子は</span><span class="keep-together">海洋循環を模した</span><span class="keep-together">流体場に従って動きます。</span><span class="keep-together">キック音に合わせた</span><span class="keep-together">拍動が没入感を</span><span class="keep-together">高めます。</span></p>
            </div>
        </div>
    </div>
</section>

<section id="footer-section" style="text-align: center;">
    <div class="container">
        <h2>Enter the Void / <span class="keep-together">深淵へ</span></h2>
        <p style="margin: 0 auto 10px;">
            <span class="keep-together">Codequariumは、</span><span class="keep-together">音楽と計算が</span><span class="keep-together">融合する</span><span class="keep-together">実験的な</span><span class="keep-together">デジタル水槽です。</span>
        </p>
        <p id="error-notice" style="font-size: 11px; opacity: 0.5; margin-bottom: 30px;">
            <span class="keep-together">※サンプル再生には</span><span class="keep-together">ローカルサーバー（Live Server等）が</span><span class="keep-together">必要です。</span>
        </p>
        <a href="https://www.threads.net/@hogushiya_kida?xmt=AQF0jg1JRo6B5FOakS_Gv36JaTHkwzBeYu6f729XkxglZCo" class="mystic-link" target="_blank">Connect on Threads / <span class="keep-together">Threadsで繋がる</span></a>
    </div>
</section>

<footer style="padding: 60px; text-align: center; font-size: 8px; opacity: 0.3; letter-spacing: 0.5em;">
    &copy; 2025 CODEQUARIUM PROJECT. CRAFTED BY CODE.
</footer>

<script>
    /**
     * CODEQUARIUM CORE ENGINE - Fixed Audio Context & Interaction Loop
     */
    const bgCanvas = document.getElementById('background-layer');
    const canvas = document.getElementById('art-canvas');
    const uiCanvas = document.getElementById('ui-canvas');
    const bgCtx = bgCanvas.getContext('2d');
    const ctx = canvas.getContext('2d');
    const uictx = uiCanvas.getContext('2d');
    const mount = document.getElementById('visualizer-mount');
    const vignette = document.getElementById('vignette');
    const nodeDisplay = document.getElementById('node-count-display');
    const displayTitle = document.getElementById('display-title');
    const fileInput = document.getElementById('file-input');
    const aspectBtn = document.getElementById('aspect-btn');
    const playPauseBtn = document.getElementById('play-pause-btn');

    let audioCtx, analyser, dataArray, prevDataArray, source, audioBuffer;
    let isInitialized = false, isPlaying = false;
    let startTime = 0, pauseOffset = 0;
    let currentMode = 'FLOW', globalVol = 0;
    
    let mouse = { x: 0, y: 0, globalX: 0, globalY: 0, active: false, down: false, influence: 0 };
    let dragNode = null; 
    let rotateX = 0, rotateY = 0;

    const MAX_NODES = 16; 
    const PARTICLE_COUNT = 150; 
    let lastEvolutionTime = 0;
    const EVOLUTION_INTERVAL = 12;

    const FRICTION = 0.993; 
    const VISCOSITY = 0.012; 
    const BASE_SPEED_LIMIT = 0.45;

    class PhysicalPoint {
        constructor(x, y) {
            this.x = x; this.y = y; this.vx = 0; this.vy = 0;
            this.targetX = x; this.targetY = y;
        }
        solve(dynamicBoost = 0) {
            const dx = this.targetX - this.x;
            const dy = this.targetY - this.y;
            this.vx += dx * VISCOSITY; this.vy += dy * VISCOSITY;
            const limit = BASE_SPEED_LIMIT + dynamicBoost;
            const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy) || 0.01;
            if (speed > limit) { this.vx = (this.vx / speed) * limit; this.vy = (this.vy / speed) * limit; }
            this.x += this.vx; this.y += this.vy;
            this.vx *= FRICTION; this.vy *= FRICTION;
        }
    }

    class SwarmNode {
        constructor(id, x, y) {
            this.id = id; this.p = new PhysicalPoint(x, y); this.radius = 12;
            this.noiseSeedX = Math.random() * 2000; this.noiseSeedY = Math.random() * 2000;
            this.isDragging = false;
        }
        update(nodeVol, flux, nodes) {
            if (this.isDragging) {
                const ox = this.p.x, oy = this.p.y;
                this.p.x = mouse.x; this.p.y = mouse.y;
                this.p.vx = (this.p.x - ox) * 0.4; this.p.vy = (this.p.y - oy) * 0.4;
                this.p.targetX = this.p.x; this.p.targetY = this.p.y;
            } else {
                const t = Date.now() * 0.00005;
                const cx = canvas.width / 2; const cy = canvas.height / 2;
                let tx = cx + Math.sin(t * (0.6 + this.id * 0.08) + this.noiseSeedX) * (canvas.width * 0.32);
                let ty = cy + Math.cos(t * (0.5 + this.id * 0.12) + this.noiseSeedY) * (canvas.height * 0.32);
                
                if (mouse.influence > 0.01) {
                    const dx = mouse.x - this.p.x, dy = mouse.y - this.p.y;
                    const d = Math.sqrt(dx * dx + dy * dy) || 0.01;
                    if (d < 300) { 
                        const force = (1 - d / 300) * 50 * mouse.influence;
                        tx += (dx / d) * force; ty += (dy / d) * force; 
                    }
                }
                nodes.forEach(other => {
                    if (other === this) return;
                    const dx = other.p.x - this.p.x, dy = other.p.y - this.p.y;
                    const dist = Math.sqrt(dx*dx + dy*dy) || 0.01;
                    const minDist = (this.radius + other.radius) * 1.25;
                    if (dist < minDist) {
                        const push = (minDist - dist) * 0.025;
                        this.p.vx -= (dx / dist) * push; this.p.vy -= (dy / dist) * push;
                    }
                });
                this.p.targetX = tx; this.p.targetY = ty;
                this.p.solve(flux * 0.45);
            }
            const pad = this.radius + 35;
            if (this.p.x < pad) { this.p.vx = Math.abs(this.p.vx) * 0.6; this.p.x = pad; }
            if (this.p.x > canvas.width - pad) { this.p.vx = -Math.abs(this.p.vx) * 0.6; this.p.x = canvas.width - pad; }
            if (this.p.y < pad) { this.p.vy = Math.abs(this.p.vy) * 0.6; this.p.y = pad; }
            if (this.p.y > canvas.height - pad) { this.p.vy = -Math.abs(this.p.vy) * 0.6; this.p.y = canvas.height - pad; }
            
            const targetR = 26 + nodeVol * 80 + flux * 135;
            this.radius += (targetR - this.radius) * (targetR > this.radius ? 0.3 : 0.08);
        }
        draw(hue) {
            if (!isFinite(this.p.x) || this.radius <= 1) return;
            const g = ctx.createRadialGradient(this.p.x, this.p.y, 0, this.p.x, this.p.y, this.radius);
            const intensity = (this.isDragging || currentMode === 'BANG') ? 1.0 : 0.68;
            g.addColorStop(0, `hsla(${hue}, 80%, 92%, ${intensity})`); 
            g.addColorStop(0.2, `hsla(${hue}, 70%, 50%, 0.65)`);
            g.addColorStop(0.75, `hsla(${hue}, 90%, 5%, 0.18)`);
            g.addColorStop(1, 'transparent');
            ctx.fillStyle = g; ctx.beginPath(); ctx.arc(this.p.x, this.p.y, this.radius, 0, Math.PI * 2); ctx.fill();
        }
    }

    class BioParticle {
        constructor() { this.init(true); }
        init(randomPos = false) {
            if (randomPos) { this.x = Math.random() * bgCanvas.width; this.y = Math.random() * bgCanvas.height; } 
            else { const a = Math.random()*Math.PI*2, d = Math.random()*150; this.x = (bgCanvas.width/2) + Math.cos(a)*d; this.y = (bgCanvas.height/2) + Math.sin(a)*d; }
            this.z = Math.random() * 2 + 0.5; this.baseAngle = Math.random() * Math.PI * 2;
            this.speed = (Math.random() * 0.12 + 0.05) / this.z; this.size = Math.random() * 1.5 + 0.4;
            this.alpha = Math.random() * 0.2 + 0.1; this.flickerS = Math.random() * 0.03 + 0.01; this.vx = 0; this.vy = 0;
        }
        update(bass) {
            const cx = bgCanvas.width / 2, cy = bgCanvas.height / 2, t = Date.now() * 0.001;
            const flowA = t * (0.04 / this.z) + this.baseAngle;
            const flowX = Math.cos(flowA) * this.speed, flowY = Math.sin(flowA) * this.speed;
            const dx = this.x - cx, dy = this.y - cy, dist = Math.sqrt(dx*dx + dy*dy) || 1;
            this.vx += (dx / dist) * bass * 0.38;
            if (currentMode === 'BANG') { this.vx += (dx / dist) * 1.8; this.vy += (dy / dist) * 1.8; }
            if (mouse.influence > 0.01) {
                const mdx = this.x - mouse.globalX, mdy = this.y - mouse.globalY;
                const mdist = Math.sqrt(mdx*mdx + mdy*mdy) || 1;
                if (mdist < 300) { const f = (1 - mdist/300) * 2.8 * mouse.influence; this.vx += (mdx/mdist)*f; this.vy += (mdy/mdist)*f; }
            }
            this.x += flowX + this.vx; this.y += flowY + this.vy; this.vx *= 0.93; this.vy *= 0.93;
            if (this.x < -200 || this.x > bgCanvas.width + 200 || this.y < -200 || this.y > bgCanvas.height + 200) this.init(false);
        }
        draw(hue, bass) {
            const blink = Math.sin(Date.now() * this.flickerS) * 0.15;
            const a = this.alpha + globalVol * 0.2 + bass * 0.45 + blink;
            bgCtx.fillStyle = `hsla(${hue}, 75%, 85%, ${Math.min(1, a)})`;
            bgCtx.beginPath(); bgCtx.arc(this.x, this.y, this.size * (1 + bass * 1.6), 0, Math.PI * 2); bgCtx.fill();
        }
    }

    let nodes = []; let particles = [];

    function setup() {
        syncSizes();
        dataArray = new Uint8Array(256); prevDataArray = new Uint8Array(256);
        nodes = [new SwarmNode(0, canvas.width / 2, canvas.height / 2)];
        particles = Array.from({ length: PARTICLE_COUNT }, () => new BioParticle());
        animate();
    }

    function addEvolutionNode() {
        if (nodes.length >= MAX_NODES) return;
        const parent = nodes[Math.floor(Math.random() * nodes.length)];
        const newNode = new SwarmNode(nodes.length, parent.p.x + 5, parent.p.y + 5);
        newNode.p.vx = (Math.random() - 0.5) * 6; newNode.p.vy = (Math.random() - 0.5) * 6;
        nodes.push(newNode);
    }

    function syncSizes() {
        const oldW = canvas.width, oldH = canvas.height;
        bgCanvas.width = window.innerWidth; bgCanvas.height = window.innerHeight;
        const rect = mount.getBoundingClientRect();
        if (rect && rect.width > 0) {
            canvas.width = uiCanvas.width = rect.width; canvas.height = uiCanvas.height = rect.height;
            if (oldW > 0) {
                const cx = canvas.width / 2, cy = canvas.height / 2;
                const oldCX = oldW / 2, oldCY = oldH / 2;
                nodes.forEach(n => {
                    const offX = n.p.x - oldCX, offY = n.p.y - oldCY;
                    n.p.x = cx + offX * (canvas.width / oldW); n.p.y = cy + offY * (canvas.height / oldH);
                    const toffX = n.p.targetX - oldCX, toffY = n.p.targetY - oldCY;
                    n.p.targetX = cx + toffX * (canvas.width / oldW); n.p.targetY = cy + toffY * (canvas.height / oldH);
                });
            }
        }
    }

    function updateMousePos(e) {
        const rect = mount.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        mouse.x = clientX - rect.left; mouse.y = clientY - rect.top;
        mouse.globalX = clientX; mouse.globalY = clientY;
        rotateY = ((clientX / window.innerWidth) - 0.5) * 8; rotateX = ((clientY / window.innerHeight) - 0.5) * -8;
    }

    mount.addEventListener('mousedown', (e) => {
        mouse.down = true; updateMousePos(e);
        let target = null;
        nodes.forEach(n => { if (Math.hypot(n.p.x - mouse.x, n.p.y - mouse.y) < 120) target = n; });
        if (target) { dragNode = target; dragNode.isDragging = true; }
    });
    window.addEventListener('mousemove', (e) => { updateMousePos(e); mouse.active = true; });
    window.addEventListener('mouseup', () => { mouse.down = false; if (dragNode) { dragNode.isDragging = false; dragNode = null; } });
    mount.addEventListener('mouseleave', () => { mouse.active = false; });

    // --- 音響コントロール（エラー修正版） ---
    function startPlayback(offset) {
        if (!audioBuffer) return;
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if (audioCtx.state === 'suspended') audioCtx.resume();
        
        // アナライザーの確実な初期化
        if (!analyser) {
            analyser = audioCtx.createAnalyser();
            analyser.fftSize = 512;
            analyser.connect(audioCtx.destination);
        }
        
        if (source) {
            try { source.stop(); } catch(e) {}
            source.disconnect();
        }

        source = audioCtx.createBufferSource();
        source.buffer = audioBuffer;
        
        // 接続先を確実にチェック
        if (analyser) {
            source.connect(analyser);
            source.start(0, offset);
            startTime = audioCtx.currentTime - offset;
            isPlaying = true;
            playPauseBtn.innerText = "Pause";
            playPauseBtn.classList.add('active');
        }
    }

    function togglePlayback() {
        if (!audioBuffer) return;
        if (isPlaying) {
            pauseOffset = audioCtx.currentTime - startTime;
            if (source) source.stop();
            isPlaying = false;
            playPauseBtn.innerText = "Play";
            playPauseBtn.classList.remove('active');
        } else {
            startPlayback(pauseOffset % audioBuffer.duration);
        }
    }

    function loadSample(fileName, label) {
        fetch(fileName).then(res => {
            if(!res.ok) throw new Error("CORS or 404");
            return res.arrayBuffer();
        }).then(buffer => {
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            audioCtx.decodeAudioData(buffer, (decoded) => {
                audioBuffer = decoded;
                if (displayTitle) displayTitle.innerText = label; 
                pauseOffset = 0; startPlayback(0); isInitialized = true;
                nodes = [new SwarmNode(0, canvas.width/2, canvas.height/2)]; lastEvolutionTime = 0;
            });
        }).catch(err => {
            const notice = document.getElementById('error-notice');
            if (notice) {
                notice.style.color = "#ff3366";
                notice.innerHTML = "<span class='keep-together'>エラー：ローカルサーバーが必要です。</span><span class='keep-together'>「Import MP3」を使用してください。</span>";
            }
        });
    }
    window.loadSample = loadSample;

    fileInput.onchange = (e) => {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const reader = new FileReader();
        reader.onload = (ev) => {
            audioCtx.decodeAudioData(ev.target.result, (buf) => {
                audioBuffer = buf; 
                if (displayTitle) displayTitle.innerText = e.target.files[0].name;
                pauseOffset = 0; startPlayback(0); isInitialized = true;
                nodes = [new SwarmNode(0, canvas.width/2, canvas.height/2)]; lastEvolutionTime = 0;
            });
        };
        reader.readAsArrayBuffer(e.target.files[0]);
    };

    aspectBtn.onclick = () => {
        const is169 = mount.classList.contains('ratio-16-9');
        mount.classList.remove('ratio-16-9', 'ratio-4-5'); mount.classList.add(is169 ? 'ratio-4-5' : 'ratio-16-9');
        let animStart = null;
        function step(ts) { if(!animStart) animStart = ts; syncSizes(); if (ts - animStart < 1300) requestAnimationFrame(step); }
        requestAnimationFrame(step);
    };

    function triggerBang() {
        currentMode = 'BANG';
        if (nodes.length < MAX_NODES) addEvolutionNode();
        nodes.forEach(n => { n.p.vx += (Math.random()-0.5)*0.35; n.p.vy += (Math.random()-0.5)*0.35; });
        setTimeout(() => { if (currentMode === 'BANG') currentMode = 'FLOW'; }, 10000);
    }

    function animate() {
        requestAnimationFrame(animate);
        
        // インタラクション減衰・復帰（滑らかな戻り）
        if (mouse.active) {
            mouse.influence += (1 - mouse.influence) * 0.1;
        } else {
            mouse.influence += (0 - mouse.influence) * 0.05;
            rotateX *= 0.95; rotateY *= 0.95;
        }

        if (isInitialized && isPlaying && analyser) { 
            analyser.getByteFrequencyData(dataArray); 
            const current = audioCtx.currentTime - startTime;
            if (current > lastEvolutionTime + EVOLUTION_INTERVAL && nodes.length < MAX_NODES) {
                addEvolutionNode(); lastEvolutionTime = current;
            }
            if (current >= audioBuffer.duration) { isPlaying = false; playPauseBtn.innerText = "Play"; pauseOffset = 0; }
        } else { if (dataArray) dataArray.fill(0); }
        
        let s = 0, f = 0, b = 0, pIndex = 0;
        if (dataArray) {
            for (let i = 0; i < dataArray.length; i++) { 
                s += dataArray[i]; if (i < 15) b += dataArray[i];
                f += Math.max(0, dataArray[i] - (prevDataArray ? prevDataArray[i] : 0)); 
                if (dataArray[i] > (dataArray[pIndex] || 0)) { pIndex = i; }
            }
            const avg = s / dataArray.length / 255; const bassAvg = b / 15 / 255; const fAvg = f / dataArray.length / 255;
            globalVol = avg; 
            if (!prevDataArray) prevDataArray = new Uint8Array(256);
            prevDataArray.set(dataArray);

            const hue = (pIndex / 128) * 360 + (Date.now() * 0.003 % 360);
            if (isInitialized) {
                mount.style.setProperty('--frame-glow', `hsla(${hue}, 70%, 70%, ${avg * 0.8})`);
                mount.style.borderColor = `hsla(${hue}, 60%, 80%, ${0.1 + avg * 0.5})`;
                mount.style.boxShadow = `0 0 45px hsla(${hue}, 80%, 50%, ${avg * 0.6}), inset 0 0 100px hsla(${hue}, 80%, 15%, ${bassAvg * 0.4})`;
                vignette.style.transform = `scale(${1 + fAvg * 0.15})`; vignette.style.opacity = 0.4 + avg * 0.6;
            }

            if (currentMode !== 'BANG' && isInitialized && isPlaying && fAvg > 0.24) triggerBang();

            ctx.fillStyle = 'rgba(1, 1, 6, 0.2)'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            bgCtx.clearRect(0, 0, bgCanvas.width, bgCanvas.height);
            particles.forEach(p => { p.update(bassAvg); p.draw(hue, bassAvg); });
            uictx.clearRect(0, 0, uiCanvas.width, uiCanvas.height);
            
            mount.style.transform = `rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;
            nodeDisplay.innerText = `NODES: ${nodes.length}`;
            nodes.forEach((n, i) => { n.update(isInitialized ? dataArray[i % 32]/255 : 0, fAvg, nodes); n.draw(hue); });
            
            uictx.save();
            for (let i = 0; i < 20; i++) {
                const h = (dataArray[i] / 255) * 55; if (h <= 0) continue;
                uictx.fillStyle = `hsla(${hue}, 10%, 100%, 0.15)`;
                uictx.fillRect((uiCanvas.width/2) + i*14, uiCanvas.height - 90 - h, 2, h);
                uictx.fillRect((uiCanvas.width/2) - i*14, uiCanvas.height - 90 - h, 2, h);
            }
            uictx.restore();
        }
    }

    window.addEventListener('resize', syncSizes);
    setup();
</script>
</body>
</html>
